<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Extra Filters demo</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nouislider@15.8.1/dist/nouislider.min.css">
    <script src="https://cdn.jsdelivr.net/npm/nouislider@15.8.1/dist/nouislider.min.js"></script>

    <style>

        * {
            box-sizing: border-box;
        }

        body {
            background-color: #fff;
            padding: 0;
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        }

        .container {
            padding: 1rem;
        }

        .build-version {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 2rem 0;
            color: #a7a7a7;
            font-size: 16px;
            line-height: 1.4;
        }

        .filters {
            position: relative;
        }
        .filters-body {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .filters-grid {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1 1 auto;
            min-width: 0;
        }
        .filters-meta {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-left: auto;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        body:not(.filters-modal) .filters > .filters-body,
        body.filters-modal .filters-ghost > .filters-body {
            position: relative;
            max-width: 1100px;
            margin: 3rem auto;
            padding: 1rem;
            background-color: #f2f5f8;
            border-radius: .7rem;
        }

        @media (max-width: 768px) {
            .filters-body {
                gap: 0;
            }
            body:not(.filters-modal) .filters > .filters-body,
            body.filters-modal .filters-ghost > .filters-body {
                flex-direction: column;
                align-items: stretch;
                margin: 0;
                padding: 0;
                background: transparent;
            }
            body:not(.filters-modal) .filters > .filters-body > .filters-grid,
            body.filters-modal .filters-ghost > .filters-body > .filters-grid {
                position: relative;
                max-width: 1100px;
                padding: 1rem;
                background-color: #f2f5f8;
                border-radius: .7rem;
            }
            body:not(.filters-modal) .filters > .filters-body > .filters-meta,
            body.filters-modal .filters-ghost > .filters-body > .filters-meta {
                margin-left: 0;
                justify-content: flex-start;
            }
        }

        .filters-meta .filters-count {
            margin-left: auto;
        }

        .filters-dates {
        }
        .filters-dates-input {
            display: none;
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #d8dde4;
            border-radius: 10px;
            background: #fff;
            font-size: 15px;
            line-height: 1.4;
            color: #1f2933;
            cursor: pointer;
        }
        .filters-dates-input:focus {
            outline: none;
            border-color: #49be54;
            box-shadow: 0 0 0 2px rgba(73, 190, 84, 0.12);
        }
        .filters-dates-picker {
            position: relative;
        }
        .datespicker {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: .25rem;
        }
        .datespicker * {
            user-select: none;
        }
        .datespicker a,
        .datespicker button {
            -webkit-tap-highlight-color: transparent;
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        }
        .datespicker-nav {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            z-index: 2;
        }
        .datespicker-nav-title {
            flex: 1 1 auto;
            text-align: center;
            font-weight: 600;
            font-size: 15px;
            color: #1f2933;
        }
        .datespicker-nav-btn {
            position: relative;
            flex: 0 0 auto;
            width: 32px;
            height: 32px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: .75rem;
            border: none;
            background: #f1f5f9;
            color: #1f2933;
            cursor: pointer;
            font-family: math, 'Tahoma';
            font-weight: 100;
            font-size: 25px;
            line-height: 1;
            transition: background-color 120ms ease, color 120ms ease;
        }
        .datespicker-nav-btn:after {
            content: "";
            position: absolute;
            top: 50%;
            width: 8px;
            height: 8px;
            margin-top: -5px;
            border-right: 2px solid currentColor;
            border-bottom: 2px solid currentColor;
            transition: transform .15s ease;
        }
        .datespicker-nav-btn.datespicker-nav-btn_prev:after {
            left: 13px;
            transform: rotate(135deg);
        }
        .datespicker-nav-btn.datespicker-nav-btn_next:after {
            right: 13px;
            transform: rotate(-45deg);
        }
        .datespicker-nav-btn[disabled] {
            opacity: .25;
        }
        .datespicker-nav-btn:hover {
            background: #e2e8f0;
        }
        .datespicker-calendars {
            display: grid;
            align-items: center;
            justify-content: center;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 8px;
            overflow: hidden;
        }
        .datespicker-month {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .datespicker-month-name {
            display: none;
            padding-right: 1rem;
            color: #1f2933;
            font-size: 14px;
            font-weight: 500;
            text-transform: capitalize;
            text-align: right;
        }
        .datespicker-weekdays,
        .datespicker-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
        }
        .datespicker-weekday {
            color: #889eb4;
            font-size: 14px;
            font-weight: 500;
            text-align: center;
        }
        .datespicker-day {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: .75rem;
            background: transparent;
            font-size: 14px;
            color: #1f2933;
            cursor: pointer;
            transition: background-color 120ms ease, color 120ms ease;
        }
        .datespicker-day:focus-visible {
            outline: 2px solid #49be54;
            outline-offset: 2px;
        }
        .datespicker-day:hover {
            background: rgba(73, 190, 84, 0.1);
        }
        .datespicker-day.is-outside {
            height: 0 !important;
            padding: 0;
            opacity: 0;
            overflow: hidden;
            pointer-events: none;
            color: #9aa5b1;
        }
        .datespicker-day.is-today {
        }
        .datespicker-day.is-range {
            border-radius: 0;
            background: rgba(73, 190, 84, 0.18);
            color: #1f2933;
        }
        .datespicker-day.is-range.is-outside {
            background: rgba(73, 190, 84, 0.07);
            color: #9aa5b1;
        }
        .datespicker-day.is-range-start,
        .datespicker-day.is-range-end {
            background: #49be54;
            color: #ffffff;
        }
        .datespicker-day.is-range-start.is-outside,
        .datespicker-day.is-range-end.is-outside {
            background: rgba(73, 190, 84, .41);
            color: #ffffff;
        }
        .datespicker-day.is-range-start.is-range-end {
            border-radius: .75rem;
        }
        .datespicker-day.is-range.is-to-left.is-range-start {
            border-radius: 0 .75rem .75rem 0;
        }
        .datespicker-day.is-range.is-to-left.is-range-end {
            border-radius: 0 .75rem .75rem 0;
        }
        .datespicker-day.is-to-right.is-range-start {
            border-radius: .75rem 0 0 .75rem;
        }
        .datespicker-day.is-to-right.is-range-end {
            border-radius: .75rem 0 0 .75rem;
        }
        .datespicker-day.is-disabled {
            color: #cbd2d9;
            cursor: default;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .datespicker-calendars {
                grid-template-columns: repeat(auto-fit, min(100%, 422px));
            }
            .datespicker-month.datespicker-month_right {
                padding-top: 8px;
            }
            .datespicker-month.datespicker-month_right .datespicker-weekdays {
                display: none;
            }
            .datespicker-month-name {
            }
        }

        @media (min-width: 769px) {
            body:not(.filters-modal) .filters > .filters-body > .filters-grid,
            body.filters-modal .filters-ghost > .filters-body > .filters-grid {
                flex-wrap: nowrap;
            }
        }

        .filters-header,
        .filters-footer,
        .filters-close {
            display: none;
        }

        .filters-open {
            display: inline-flex;
            align-items: center;
            gap: .16rem;
            padding: 8px 9px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #fff;
            cursor: pointer;
            white-space: nowrap;
            flex: 0 0 auto;
            position: relative;
        }
        .filters-open-badge {
            position: absolute;
            top: -6px;
            right: -6px;
            min-width: 20px;
            height: 20px;
            padding: 0 6px;
            border-radius: 999px;
            background: #ff4d4f;
            color: #fff;
            font-size: 12px;
            font-weight: 600;
            line-height: 20px;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .filters-open-badge.is-visible {
            display: inline-flex;
        }
        .filters-open-icon {
            flex: 0 0 auto;
            width: 18px;
            height: 18px;
            color: #616161;
        }
        .filters-open-icon svg {
            display: block;
            width: 100%;
            height: 100%;
            fill: currentColor;
        }
        .filters-open-prefix {
            display: inline;
        }
        @media (max-width: 991px) {
            .filters-open-prefix {
                display: none;
            }
            .filters-open {
                text-transform: capitalize;
            }
        }

        body.filters-modal .filters {
            position: fixed;
            z-index: 10000;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: #fff;
            width: min(700px, 90vw);
            max-height: max(700px, 80vh);
            margin: 0;
            padding: 0;
            border-radius: .7rem;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        body.filters-modal .filters .filters-open {
            display: none;
        }

        body.filters-modal .filters .filters-body {
            display: flex;
            align-items: flex-start;
            flex-direction: column;
            flex: 1 1 auto;
            gap: 12px;
            padding: 16px 16px;
            max-height: calc(80vh - 90px);
            overflow: auto;
        }

        body.filters-modal .filters .filters-meta {
            justify-content: flex-start;
            width: 100%;
            padding: 0;
            margin-left: 0;
            border: 0;
        }

        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,.35);
            z-index: 9000;
        }

        body.filters-modal .filters .filters-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            border-bottom: 1px solid #eee;
            position: relative;
            z-index: 1;
        }
        body.filters-modal .filters .filters-title {
            font-weight: 600;
        }
        body.filters-modal .filters .filters-close {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 10px;
            border: 1px solid #eee;
            background: #fff;
            cursor: pointer;
            color: #616161;
            font-family: 'Tahoma';
            font-size: 16px;
            font-weight: 100;
            line-height: 1;
        }
        body.filters-modal .filters .filters-grid {
            flex: 1 1 auto;
            overflow: initial;
            padding: 0;
            flex-wrap: wrap;
        }
        body.filters-modal .filters .filters-footer {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            padding: 12px 16px;
            border-top: 1px solid #eee;
            background: #fff;
            position: relative;
            z-index: 1;
        }
        .filters-btn {
            padding: 10px 14px;
            border-radius: 10px;
            cursor: pointer;
            border: 1px solid #ddd;
            background: #fff;
        }
        .filters-btn.primary {
            background: #49be54;
            border-color: #49be54;
            color: #fff;
        }
        @media (max-width: 768px) {
            body.filters-modal .filters .filters-footer {
                justify-content: space-between;
            }
        }

        .filters-extra-checks {
            display: none;
            width: 100%;
        }
        .filters-extra-checks .check-row {
            display: flex;
            flex-flow: row wrap;
            gap: 8px;
            margin-top: 8px;
        }
        .filters-extra-checks label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 8px 10px;
        }
        body.filters-modal .filters .filters-extra-checks {
            display: block;
        }

        @media (min-width: 769px) {
            body.filters-modal .filters .filters-grid .extra-select:not(.extra-select_sort) {
                flex: 1 1 calc(50% - 6px);
                max-width: calc(50% - 6px);
            }
        }

        .filters-ghost {
            opacity: .65;
            pointer-events: none;
            user-select: none;
        }
        .filters-ghost .exs-popover {
            display: none !important;
        }

        .extra-select {
            position: relative;
            display: inline-flex;
            flex: 1 1 auto;
            min-width: 97px;
        }
        .extra-select.extra-select_full-value {
            min-width: 124px;
        }
        .extra-select.is-filled:not(.extra-select_sort)::before {
            content: attr(data-placeholder);
            position: absolute;
            top: 5px;
            left: 12px;
            font-size: 10px;
            line-height: 1;
            color: #616161;
            pointer-events: none;
            max-width: calc(100% - 48px);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            z-index: 1;
            padding-left: 1px;
        }
        .extra-select.is-filled:not(.extra-select_sort) .exs-trigger {
            padding: 15px 36px 5px 12px;
        }
        .extra-select_has-icon.is-filled:not(.extra-select_sort)::before {
            left: 33.1px;
            max-width: calc(100% - 80px);
        }
        .extra-select_sort {
            flex: 0 0 auto;
            min-width: inherit !important;
        }

        .exs-trigger {
            position: relative;
            width: 100%;
            padding: 10px 36px 10px 12px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background: #fff;
            color: #1f2933;
            line-height: 1.2;
            text-align: left;
            cursor: pointer;
        }
        .extra-select:not(.extra-select_has-icon) .exs-trigger {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .extra-select.extra-select_has-icon:not(.extra-select_sort) .exs-trigger {
            padding-left: 32px;
        }
        .exs-trigger[aria-expanded="true"] {
            border-color: #49be54;
        }
        .exs-trigger.is-active {
            border-color: #49be54;
            color: #49be54;
        }
        .exs-trigger::after {
            content: "";
            position: absolute;
            right: 12px;
            top: 50%;
            width: 8px;
            height: 8px;
            margin-top: -6px;
            border-right: 2px solid currentColor;
            border-bottom: 2px solid currentColor;
            transform: rotate(45deg);
            transition: transform .15s ease;
        }
        .exs-trigger[aria-expanded="true"]::after {
            transform: rotate(-135deg);
            margin-top: -2px;
        }

        .extra-select_has-icon .exs-trigger .exs-trigger-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            color: inherit;
            pointer-events: none;
        }
        .extra-select_has-icon:not(.extra-select_sort) .exs-trigger .exs-trigger-icon {
            position: absolute;
            left: 7px;
            top: 50%;
            transform: translateY(-52%);
        }
        .extra-select_has-icon:not(.extra-select_sort) .exs-trigger:not(.is-active) .exs-trigger-icon {
            color: #616161;
        }
        .exs-trigger-icon svg {
            display: block;
            width: 100%;
            height: 100%;
            fill: currentColor;
        }
        .extra-select_has-icon.is-filled:not(.extra-select_sort) .exs-trigger {
        }
        .extra-select_has-icon.extra-select_sort .exs-trigger {
        }
        .extra-select.extra-select_has-icon .exs-trigger-label {
            display: block;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .extra-select.extra-select_full-value.extra-select_has-icon.is-filled .exs-trigger-label {
            white-space: normal;
            overflow: visible;
            text-overflow: initial;
            word-break: break-word;
        }

        .extra-select_sort .exs-trigger {
            display: inline-flex;
            align-items: center;
            gap: .16rem;
            padding-left: 0;
            padding-right: 0;
            background: transparent;
            border-color: transparent;
            color: #0066cc;
            text-decoration: underline;
        }
        .extra-select_sort .exs-trigger::after {
            display: none;
        }
        .extra-select_sort .exs-trigger-label:first-letter {
            text-transform: uppercase;
        }

        .exs-popover {
            position: absolute;
            z-index: 11000;
            top: 100%;
            left: 0;
            right: 0;
            padding: 0;
            border: 0;
            border-radius: 10px;
            background: #fff;
            box-shadow: 0px 0px 24px rgba(0, 0, 0, .16);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 280px;
            opacity: 1;
            transform: translateY(0);
        }
        .exs-popover[hidden] {
            display: none !important;
        }
        .exs-body {
            max-height: calc(70vh - 52px);
            overflow: auto;
            padding: 10px;
        }
        .exs-popover label {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 6px 4px;
            cursor: pointer;
        }
        .exs-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            padding: 10px;
            border-top: 1px solid #eee;
            background: #fff;
        }

        .exs-close {
            display: none;
            position: absolute;
            right: 9px;
            top: 9px;
            z-index: 2;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 10px;
            border: 1px solid #eee;
            background: #fff;
            cursor: pointer;
            color: #616161;
            font-family: 'Tahoma';
            font-size: 16px;
            font-weight: 100;
            line-height: 1;
        }
        .exs-drag-handle {
            display: none;
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            height: 40px;
            z-index: 1;
            touch-action: none;
            cursor: grab;
        }
        .exs-drag-handle::after {
            content: "";
            position: absolute;
            left: 50%;
            top: 5px;
            width: 46px;
            height: 4px;
            margin-left: -23px;
            border-radius: 999px;
            background: #ddd;
        }
        .exs-header {
            display: none;
            padding: 22px 14px 0;
            font-size: 17px;
            font-weight: 600;
            line-height: 1;
            text-align: center;
        }

        @keyframes exsSlideUpBounce {
            0% { transform: translateY(100%); }
            75% { transform: translateY(-6%); }
            100% { transform: translateY(0); }
        }
        @keyframes exsSlideDown {
            from { transform: translateY(0); }
            to   { transform: translateY(100%); }
        }

        @media (min-width: 769px) {
            .extra-select.extra-select_full-value {
                flex: none;
            }
            .exs-popover[data-field-key="dates"] {
                min-width: 520px;
            }
            .exs-popover[data-field-key="sort"] .exs-header {
                display: block;
                padding: 16px 14px 7px;
            }
        }
        @media (max-width: 768px) {
            .exs-popover {
                position: fixed;
                left: 0;
                right: 0;
                bottom: -160px;
                top: auto;
                max-height: calc(80vh + 160px);
                height: auto;
                border-radius: 16px 16px 0 0;
                margin: 0;
                padding-top: 0;
                padding-bottom: 160px;
                will-change: transform;
                touch-action: none;
                z-index: 11000;
                display: flex;
                flex-direction: column;
            }
            .exs-popover[data-open="true"] { animation: exsSlideUpBounce .25s cubic-bezier(.22,1,.36,1) both; }
            .exs-popover[data-closing="true"] { animation: exsSlideDown .18s ease both; }
            .exs-header { display: block; }
            .exs-body { max-height: calc(calc(80vh + 160px) - 60px - 40px); overflow: auto; }
            .exs-actions {
                justify-content: space-between;
                position: relative;
                padding: 10px 14px;
            }
            .exs-close { display: inline-flex; }
            .exs-drag-handle { display: block; }

            .exs-popover[data-field-key="dates"] .exs-header,
            .exs-popover[data-field-key="dates"] .exs-close {
                display: none !important;
            }
        }

        .exs-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,.12);
            z-index: 10990;
        }

        .noUi-target { border: 0; box-shadow: none; }
        .noUi-horizontal { height: 6px; }
        .noUi-connect { background: #49be54; }
        .noUi-base, .noUi-connects { border-radius: 3px; background: #eee; }
        .noUi-handle {
            border-radius: 50%;
            width: 18px !important;
            height: 18px !important;
            right: -9px !important;
            top: -7px !important;
            border: 2px solid #fff;
            background: #49be54;
            box-shadow: 0 0 0 1px #49be54;
        }
        .noUi-handle:before, .noUi-handle:after { display: none; }

        .exs-price-row {
            display: flex;
            flex-direction: row;
            gap: 12px;
            width: 100%;
        }
        .exs-price-field {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex: 1 1 0;
        }
        .exs-price-field input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-sizing: border-box;
        }
        .exs-range {
            padding: 18px 14px 25px;
            margin-bottom: -10px;
        }
        .exs-range-plugin {
            margin: 0;
        }

        body:not(.filters-modal) .filters > .filters-body > .filters-grid > *,
        body.filters-modal .filters-ghost > .filters-body > .filters-grid > * {
            display: none;
        }
        body:not(.filters-modal) .filters > .filters-body > .filters-meta > *,
        body.filters-modal .filters-ghost > .filters-body > .filters-meta > * {
            display: none;
        }

        body:not(.filters-modal) .filters > .filters-body > .filters-grid > [data-order="10"],
        body.filters-modal .filters-ghost > .filters-body > .filters-grid > [data-order="10"] { order: 10; }
        body:not(.filters-modal) .filters > .filters-body > .filters-grid > [data-order="20"],
        body.filters-modal .filters-ghost > .filters-body > .filters-grid > [data-order="20"] { order: 20; }
        body:not(.filters-modal) .filters > .filters-body > .filters-grid > [data-order="30"],
        body.filters-modal .filters-ghost > .filters-body > .filters-grid > [data-order="30"] { order: 30; }
        body:not(.filters-modal) .filters > .filters-body > .filters-grid > [data-order="40"],
        body.filters-modal .filters-ghost > .filters-body > .filters-grid > [data-order="40"] { order: 40; }
        body:not(.filters-modal) .filters > .filters-body > .filters-grid > [data-order="50"],
        body.filters-modal .filters-ghost > .filters-body > .filters-grid > [data-order="50"] { order: 50; }
        body:not(.filters-modal) .filters > .filters-body > .filters-grid > [data-order="55"],
        body.filters-modal .filters-ghost > .filters-body > .filters-grid > [data-order="55"] { order: 55; }
        body:not(.filters-modal) .filters > .filters-body > .filters-meta > [data-order="60"],
        body.filters-modal .filters-ghost > .filters-body > .filters-meta > [data-order="60"] { order: 60; }
        body:not(.filters-modal) .filters > .filters-body > .filters-meta > [data-order="70"],
        body.filters-modal .filters-ghost > .filters-body > .filters-meta > [data-order="70"] { order: 70; }

        body:not(.filters-modal) .filters > .filters-body > .filters-meta > .filters-count,
        body.filters-modal .filters-ghost > .filters-body > .filters-meta > .filters-count {
            white-space: nowrap;
            color: #616161;
            font-size: 14px;
        }

        @media (min-width: 992px) {
            body:not(.filters-modal) .filters > .filters-body > .filters-grid > .extra-select[data-show-panel-xl="true"],
            body.filters-modal .filters-ghost > .filters-body > .filters-grid > .extra-select[data-show-panel-xl="true"],
            body:not(.filters-modal) .filters > .filters-body > .filters-grid > .filters-open[data-show-panel-xl="true"],
            body.filters-modal .filters-ghost > .filters-body > .filters-grid > .filters-open[data-show-panel-xl="true"] {
                display: inline-flex;
            }
            body:not(.filters-modal) .filters > .filters-body > .filters-grid > .filters-break-line[data-show-panel-xl="true"],
            body.filters-modal .filters-ghost > .filters-body > .filters-grid > .filters-break-line[data-show-panel-xl="true"] {
                display: block;
            }
            body:not(.filters-modal) .filters > .filters-body > .filters-meta > .extra-select[data-show-panel-xl="true"],
            body.filters-modal .filters-ghost > .filters-body > .filters-meta > .extra-select[data-show-panel-xl="true"] {
                display: inline-flex;
            }
            body:not(.filters-modal) .filters > .filters-body > .filters-meta > .filters-count[data-show-panel-xl="true"],
            body.filters-modal .filters-ghost > .filters-body > .filters-meta > .filters-count[data-show-panel-xl="true"] {
                display: block;
            }
        }

        @media (min-width: 769px) and (max-width: 991px) {
            body:not(.filters-modal) .filters > .filters-body > .filters-grid > .extra-select[data-show-panel-m="true"],
            body.filters-modal .filters-ghost > .filters-body > .filters-grid > .extra-select[data-show-panel-m="true"],
            body:not(.filters-modal) .filters > .filters-body > .filters-grid > .filters-open[data-show-panel-m="true"],
            body.filters-modal .filters-ghost > .filters-body > .filters-grid > .filters-open[data-show-panel-m="true"] {
                display: inline-flex;
            }
            body:not(.filters-modal) .filters > .filters-body > .filters-grid > .filters-break-line[data-show-panel-m="true"],
            body.filters-modal .filters-ghost > .filters-body > .filters-grid > .filters-break-line[data-show-panel-m="true"] {
                display: block;
            }
            body:not(.filters-modal) .filters > .filters-body > .filters-meta > .extra-select[data-show-panel-m="true"],
            body.filters-modal .filters-ghost > .filters-body > .filters-meta > .extra-select[data-show-panel-m="true"] {
                display: inline-flex;
            }
            body:not(.filters-modal) .filters > .filters-body > .filters-meta > .filters-count[data-show-panel-m="true"],
            body.filters-modal .filters-ghost > .filters-body > .filters-meta > .filters-count[data-show-panel-m="true"] {
                display: block;
            }
        }

        body.filters-modal .filters .filters-meta > .filters-count {
            display: none !important;
        }

        @media (min-width: 992px) {
            .extra-select { min-width: 97px; }
            .extra-select.extra-select_full-value { min-width: 124px; }
        }

        @media (max-width: 991px) {
            body:not(.filters-modal) .filters > .filters-body > .filters-grid > .extra-select,
            body.filters-modal .filters-ghost > .filters-body > .filters-grid > .extra-select {
                min-width: 97px;
            }
            body:not(.filters-modal) .filters > .filters-body > .filters-grid > .extra-select.extra-select_full-value,
            body.filters-modal .filters-ghost > .filters-body > .filters-grid > .extra-select.extra-select_full-value {
                min-width: 124px;
            }
        }

        @media (max-width: 768px) {
            body:not(.filters-modal) .filters > .filters-body > .filters-grid,
            body.filters-modal .filters-ghost > .filters-body > .filters-grid {
                gap: 10px 12px;
            }

            body:not(.filters-modal) .filters > .filters-body > .filters-grid > .extra-select[data-show-panel-xs="true"],
            body.filters-modal .filters-ghost > .filters-body > .filters-grid > .extra-select[data-show-panel-xs="true"],
            body:not(.filters-modal) .filters > .filters-body > .filters-grid > .filters-open[data-show-panel-xs="true"],
            body.filters-modal .filters-ghost > .filters-body > .filters-grid > .filters-open[data-show-panel-xs="true"] {
                display: inline-flex;
            }
            body:not(.filters-modal) .filters > .filters-body > .filters-grid > .filters-break-line[data-show-panel-xs="true"],
            body.filters-modal .filters-ghost > .filters-body > .filters-grid > .filters-break-line[data-show-panel-xs="true"] {
                display: block;
                flex: 0 0 100%;
                height: 0;
                overflow: hidden;
            }
            body:not(.filters-modal) .filters > .filters-body > .filters-meta > .extra-select[data-show-panel-xs="true"],
            body.filters-modal .filters-ghost > .filters-body > .filters-meta > .extra-select[data-show-panel-xs="true"] {
                display: inline-flex;
                max-width: none;
                flex: 1 1 auto;
            }
            body:not(.filters-modal) .filters > .filters-body > .filters-meta > .filters-count[data-show-panel-xs="true"],
            body.filters-modal .filters-ghost > .filters-body > .filters-meta > .filters-count[data-show-panel-xs="true"] {
                display: block;
            }
            body:not(.filters-modal) .filters > .filters-body > .filters-grid > [data-order-xs="20"],
            body.filters-modal .filters-ghost > .filters-body > .filters-grid > [data-order-xs="20"] {
                order: 20;
            }
        }

        body.filters-modal .filters .filters-body .filters-grid > .extra-select {
            display: inline-flex !important;
        }
        @media (max-width: 768px) {
            body.filters-modal .filters .filters-body .filters-grid {
                align-items: stretch;
            }
            body.filters-modal .filters .filters-body .filters-grid > * {
                flex: 1 0 100%;
            }
        }
    </style>
</head>
<body>

    <div class="container">
    <div class="build-version">
        Build: 0.0.017
    </div>

    <form class="filters-form js-filters-form" action="" method="GET">
        <div class="filters" id="filters" aria-label="Фильтры">
            <div class="filters-header">
                <div class="filters-title">Все фильтры</div>
                <button type="button" class="filters-close js-filters-close" aria-label="Закрыть">×</button>
            </div>
            <div class="filters-body">
                <div class="filters-grid" data-filters-scope>
                <div class="extra-select js-extra-select extra-select_full-value extra-select_has-icon"
                     data-order="10"
                     data-type="dates"
                     data-field="dates"
                     data-placeholder="Даты"
                     data-max-label-chars="28"
                     data-show-panel-xl="true"
                     data-show-panel-m="true"
                     data-show-panel-xs="true">
                    <button type="button"
                            class="exs-trigger js-exs-trigger"
                            aria-haspopup="dialog"
                            aria-expanded="false"
                            aria-controls="exs-popover-dates">
                        <span class="exs-trigger-icon" aria-hidden="true">
                            <svg preserveAspectRatio="none"
                                 width="100%"
                                 height="100%"
                                 viewBox="0 0 24 24"
                                 xmlns="http://www.w3.org/2000/svg">
                                <g></g>
                                <g>
                                    <path d="M19,4h-1V2h-2v2H8V2H6v2H5C3.89,4,3.01,4.9,3.01,6L3,20c0,1.1,0.89,2,2,2h14c1.1,0,2-0.9,2-2V6C21,4.9,20.1,4,19,4z M19,20 H5V10h14V20z M9,14H7v-2h2V14z M13,14h-2v-2h2V14z M17,14h-2v-2h2V14z M9,18H7v-2h2V18z M13,18h-2v-2h2V18z M17,18h-2v-2h2V18z"></path>
                                </g>
                            </svg>
                        </span>
                        <span class="exs-trigger-label" data-trigger-label>Даты</span>
                    </button>
                    <div class="exs-popover js-exs-popover" id="exs-popover-dates" data-field-key="dates" role="dialog" hidden>
                        <div class="exs-drag-handle"></div>
                        <button type="button" class="exs-close js-exs-close" aria-label="Закрыть">×</button>
                        <div class="exs-header">Даты</div>
                        <div class="exs-body">
                            <div class="filters-dates js-filters-dates">
                                <input type="text"
                                       class="filters-dates-input js-dates-input"
                                       inputmode="none"
                                       value=""
                                       data-datespicker-value=""
                                       placeholder="Выберите даты"
                                       readonly>
                                <div class="filters-dates-picker js-dates-picker"></div>
                            </div>
                        </div>
                        <div class="exs-actions">
                            <button type="button" class="filters-btn" data-action="reset">Сбросить</button>
                            <button type="button" class="filters-btn primary" data-action="apply">Применить</button>
                        </div>
                    </div>
                    <div class="exs-hidden js-exs-hidden"></div>
                </div>

                <div class="extra-select js-extra-select"
                     data-order="20"
                     data-type="checkbox"
                     data-field="format"
                     data-placeholder="Формат экскурсий"
                     data-max-label-chars="28"
                     data-show-panel-xl="true"
                     data-show-panel-m="true"
                     data-show-panel-xs="false">
                    <button type="button"
                            class="exs-trigger js-exs-trigger"
                            aria-haspopup="listbox"
                            aria-expanded="false"
                            aria-controls="exs-popover-format">Формат экскурсий</button>
                    <div class="exs-popover js-exs-popover" id="exs-popover-format" data-field-key="format" role="listbox" aria-multiselectable="true" hidden>
                        <div class="exs-drag-handle"></div>
                        <button type="button" class="exs-close js-exs-close" aria-label="Закрыть">×</button>
                        <div class="exs-header">Формат экскурсий</div>
                        <div class="exs-body js-exs-body">
                            <label><input type="checkbox" value="Групповые"> Групповые</label>
                            <label><input type="checkbox" value="Мини-группы"> Мини-группы</label>
                            <label><input type="checkbox" value="Индивидуальные"> Индивидуальные</label>
                        </div>
                        <div class="exs-actions">
                            <button type="button" class="filters-btn" data-action="reset">Сбросить</button>
                            <button type="button" class="filters-btn primary" data-action="apply">Применить</button>
                        </div>
                    </div>
                    <div class="exs-hidden js-exs-hidden">
                        <input type="hidden" name="format[]" value="Групповые">
                        <input type="hidden" name="format[]" value="Мини-группы">
                    </div>
                </div>

                <div class="extra-select js-extra-select"
                     data-order="30"
                     data-type="checkbox"
                     data-field="transport"
                     data-placeholder="Способ передвижения"
                     data-max-label-chars="28"
                     data-show-panel-xl="true"
                     data-show-panel-m="true"
                     data-show-panel-xs="false">
                    <button type="button"
                            class="exs-trigger js-exs-trigger"
                            aria-haspopup="listbox"
                            aria-expanded="false"
                            aria-controls="exs-popover-transport">Способ передвижения</button>
                    <div class="exs-popover js-exs-popover" id="exs-popover-transport" data-field-key="transport" role="listbox" aria-multiselectable="true" hidden>
                        <div class="exs-drag-handle"></div>
                        <button type="button" class="exs-close js-exs-close" aria-label="Закрыть">×</button>
                        <div class="exs-header">Способ передвижения</div>
                        <div class="exs-body js-exs-body">
                            <label><input type="checkbox" value="Пешком"> Пешком</label>
                            <label><input type="checkbox" value="На автобусе"> На автобусе</label>
                            <label><input type="checkbox" value="На автомобиле"> На автомобиле</label>
                            <label><input type="checkbox" value="На мотоцикле"> На мотоцикле</label>
                            <label><input type="checkbox" value="На велосипеде"> На велосипеде</label>
                            <label><input type="checkbox" value="На теплоходе"> На теплоходе</label>
                            <label><input type="checkbox" value="На яхте"> На яхте</label>
                            <label><input type="checkbox" value="На катере"> На катере</label>
                            <label><input type="checkbox" value="Другое"> Другое</label>
                        </div>
                        <div class="exs-actions">
                            <button type="button" class="filters-btn" data-action="reset">Сбросить</button>
                            <button type="button" class="filters-btn primary" data-action="apply">Применить</button>
                        </div>
                    </div>
                    <div class="exs-hidden js-exs-hidden"></div>
                </div>

                <div class="extra-select js-extra-select extra-select_full-value"
                     data-order="40"
                     data-type="range"
                     data-field="price"
                     data-placeholder="Цены"
                     data-min="0"
                     data-max="100000"
                     data-step="1000"
                     data-show-panel-xl="true"
                     data-show-panel-m="false"
                     data-show-panel-xs="false">
                    <button type="button"
                            class="exs-trigger js-exs-trigger"
                            aria-haspopup="dialog"
                            aria-expanded="false"
                            aria-controls="exs-popover-price">Цены</button>
                    <div class="exs-popover js-exs-popover" id="exs-popover-price" data-field-key="price" role="dialog" hidden>
                        <div class="exs-drag-handle"></div>
                        <button type="button" class="exs-close js-exs-close" aria-label="Закрыть">×</button>
                        <div class="exs-header">Цены</div>
                        <div class="exs-body">
                            <div class="exs-price-row">
                                <label class="exs-price-field">
                                    <span>От</span>
                                    <input type="number" class="exs-from js-exs-from" inputmode="numeric" placeholder="от">
                                </label>
                                <label class="exs-price-field">
                                    <span>До</span>
                                    <input type="number" class="exs-to js-exs-to" inputmode="numeric" placeholder="до">
                                </label>
                            </div>
                            <div class="exs-range">
                                <div class="exs-range-plugin js-exs-range js-exs-swipe-lock" id="price-plugin"></div>
                            </div>
                        </div>
                        <div class="exs-actions">
                            <button type="button" class="filters-btn" data-action="reset">Сбросить</button>
                            <button type="button" class="filters-btn primary" data-action="apply">Применить</button>
                        </div>
                    </div>
                    <div class="exs-hidden js-exs-hidden"></div>
                </div>

                <div class="extra-select js-extra-select"
                     data-type="checkbox"
                     data-field="duration"
                     data-placeholder="Длительность"
                     data-max-label-chars="28"
                     data-show-panel-xl="false"
                     data-show-panel-m="false"
                     data-show-panel-xs="false">
                    <button type="button"
                            class="exs-trigger js-exs-trigger"
                            aria-haspopup="listbox"
                            aria-expanded="false"
                            aria-controls="exs-popover-duration">Длительность</button>
                    <div class="exs-popover js-exs-popover" id="exs-popover-duration" data-field-key="duration" role="listbox" hidden aria-multiselectable="true">
                        <div class="exs-drag-handle"></div>
                        <button type="button" class="exs-close js-exs-close" aria-label="Закрыть">×</button>
                        <div class="exs-header">Длительность</div>
                        <div class="exs-body js-exs-body">
                            <label><input type="checkbox" value="до 2 часов"> до 2 часов</label>
                            <label><input type="checkbox" value="от 2 до 4"> от 2 до 4</label>
                            <label><input type="checkbox" value="от 4 до 6"> от 4 до 6</label>
                            <label><input type="checkbox" value="6+ часов"> 6+ часов</label>
                        </div>
                        <div class="exs-actions">
                            <button type="button" class="filters-btn" data-action="reset">Сбросить</button>
                            <button type="button" class="filters-btn primary" data-action="apply">Применить</button>
                        </div>
                    </div>
                    <div class="exs-hidden js-exs-hidden"></div>
                </div>

                <button type="button"
                        class="filters-open js-filters-open"
                        data-order="50"
                        data-order-xs="20"
                        data-filters-open
                        data-show-panel-xl="true"
                        data-show-panel-m="true"
                        data-show-panel-xs="true">
                    <span class="filters-open-icon" aria-hidden="true">
                        <svg preserveAspectRatio="none" width="100%" viewBox="0 0 24 24" height="100%" xmlns="http://www.w3.org/2000/svg">
                            <path d="M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8v-2h-2v6h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z"></path>
                        </svg>
                    </span>
                    <span class="filters-open-prefix">Все </span>фильтры
                    <span class="filters-open-badge js-filters-open-badge" aria-hidden="true"></span>
                </button>

                <div class="filters-extra-checks"
                     data-show-panel-xl="false"
                     data-show-panel-m="false"
                     data-show-panel-xs="false">
                    <div class="check-row">
                        <label><input type="checkbox" name="no_prepay" value="1"> Без предоплаты</label>
                        <label><input type="checkbox" name="with_discount" value="1"> Со скидкой</label>
                        <label><input type="checkbox" name="editors_choice" value="1" checked> Выбор редакции</label>
                    </div>
                </div>

                </div>
                <div class="filters-meta">
                    <div class="extra-select js-extra-select extra-select_sort extra-select_has-icon"
                         data-type="radio"
                         data-field="sort"
                         data-placeholder="Сортировка"
                         data-show-panel-xl="true"
                         data-show-panel-m="true"
                         data-show-panel-xs="true"
                         data-order="60">
                        <button type="button"
                                class="exs-trigger js-exs-trigger"
                                aria-haspopup="listbox"
                                aria-expanded="false"
                                aria-controls="exs-popover-sort">
                            <span class="exs-trigger-icon" aria-hidden="true">
                                <svg preserveAspectRatio="none" width="100%" viewBox="0 0 24 24" height="100%" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M16 17.01V10h-2v7.01h-3L15 21l4-3.99h-3zM9 3L5 6.99h3V14h2V6.99h3L9 3z"></path>
                                </svg>
                            </span>
                            <span class="exs-trigger-label" data-trigger-label></span>
                        </button>
                        <div class="exs-popover js-exs-popover" id="exs-popover-sort" data-field-key="sort" role="listbox" hidden>
                            <div class="exs-drag-handle"></div>
                            <button type="button" class="exs-close js-exs-close" aria-label="Закрыть">×</button>
                            <div class="exs-header">Показать сначала</div>
                            <div class="exs-body js-exs-body">
                                <label><input type="radio" name="sort-radio" value="recommended" data-label="рекомендуемые" data-is-default="true"> рекомендуемые</label>
                                <label><input type="radio" name="sort-radio" value="popular"     data-label="популярные"> популярные</label>
                                <label><input type="radio" name="sort-radio" value="rating"      data-label="с высоким рейтингом" checked> с высоким рейтингом</label>
                                <label><input type="radio" name="sort-radio" value="cheap"       data-label="дешевле"> дешевле</label>
                                <label><input type="radio" name="sort-radio" value="expensive"   data-label="дороже"> дороже</label>
                            </div>
                        </div>
                        <div class="exs-hidden js-exs-hidden">
                            <input type="hidden" name="sort" value="rating">
                        </div>
                    </div>

                    <div class="filters-count"
                         data-show-panel-xl="false"
                         data-show-panel-m="false"
                         data-show-panel-xs="true"
                         data-order="70">720 экскурсий</div>
                </div>
            </div>

            <div class="filters-footer">
                <button type="button" class="filters-btn js-filters-reset-all" data-filters-reset-all>Сбросить всё</button>
                <button type="button" class="filters-btn primary js-filters-apply-all" data-filters-apply-all>Показать</button>
            </div>
        </div>
    </form>
</div>

<script>
    (function () {
        "use strict";

        const form = document.querySelector(".js-filters-form");
        if (!form) {
            return;
        }

        function submitAjax() {
            const fd = new FormData(form);
            const params = new URLSearchParams();
            for (const [key, value] of fd.entries()) {
                params.append(key, value);
            }
            const query = params.toString();
            const url = location.pathname + (query ? ("?" + query) : "");
            fetch(url, { method: "GET", credentials: "same-origin" }).catch(() => {});
        }

        form.querySelectorAll(".filters-extra-checks input[type=\"checkbox\"]").forEach((checkbox) => {
            checkbox.addEventListener("change", () => {
                submitAjax();
            });
        });

        const debugBucket = window.FiltersDebugForm || {};
        debugBucket.submitAjax = submitAjax;
        window.FiltersDebugForm = debugBucket;
    })();
</script>

<script>
    (function () {
        "use strict";

        const isMobile = () => window.matchMedia("(max-width:768px)").matches;

        const filters = document.getElementById("filters");
        const submitAjax = window.FiltersDebugForm?.submitAjax ?? (() => {});

        const MONTHS_NOMINATIVE = [
            "январь", "февраль", "март", "апрель", "май", "июнь",
            "июль", "август", "сентябрь", "октябрь", "ноябрь", "декабрь"
        ];
        const MONTHS_GENITIVE = [
            "янв", "фев", "мар", "апр", "мая", "июн",
            "июл", "авг", "сен", "окт", "ноя", "дек"
        ];
        const WEEKDAYS_SHORT = ["Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс"];

        const clampToDate = (date) => new Date(date.getFullYear(), date.getMonth(), date.getDate());
        const startOfMonth = (date) => new Date(date.getFullYear(), date.getMonth(), 1);
        const addMonths = (date, diff) => {
            const next = new Date(date.getFullYear(), date.getMonth(), 1);
            next.setMonth(next.getMonth() + diff);
            return next;
        };
        const addDays = (date, diff) => {
            const next = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            next.setDate(next.getDate() + diff);
            return next;
        };
        const parseISODate = (value) => {
            if (!value || typeof value !== "string") return null;
            const trimmed = value.trim();
            const match = trimmed.match(/^(\d{4})-(\d{2})-(\d{2})$/);
            if (!match) return null;
            const year = Number(match[1]);
            const month = Number(match[2]) - 1;
            const day = Number(match[3]);
            const date = new Date(year, month, day);
            if (date.getFullYear() !== year || date.getMonth() !== month || date.getDate() !== day) {
                return null;
            }
            return date;
        };
        const toISODate = (date) => {
            if (!(date instanceof Date)) return "";
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, "0");
            const day = String(date.getDate()).padStart(2, "0");
            return `${year}-${month}-${day}`;
        };
        const isSameDay = (a, b) => {
            if (!(a instanceof Date) || !(b instanceof Date)) return false;
            return a.getFullYear() === b.getFullYear() &&
                a.getMonth() === b.getMonth() &&
                a.getDate() === b.getDate();
        };
        const isDayBetween = (target, start, end) => {
            if (!(target instanceof Date) || !(start instanceof Date) || !(end instanceof Date)) return false;
            const t = target.getTime();
            const s = start.getTime();
            const e = end.getTime();
            if (s <= e) {
                return t >= s && t <= e;
            }
            return t >= e && t <= s;
        };
        const formatMonthTitle = (date) => {
            const month = MONTHS_NOMINATIVE[date.getMonth()] || "";
            const capitalized = month ? (month.charAt(0).toUpperCase() + month.slice(1)) : "";
            return `${capitalized} ${date.getFullYear()}`.trim();
        };
        const formatDateHuman = (date) => {
            if (!(date instanceof Date)) return "";
            return `${date.getDate()} ${MONTHS_GENITIVE[date.getMonth()]}`;
        };
        const formatRangeHuman = (start, end) => {
            if (!(start instanceof Date) || !(end instanceof Date)) return "";
            const sameDay = isSameDay(start, end);
            if (sameDay) {
                return `${formatDateHuman(start)} ${start.getFullYear()}`;
            }
            const sameYear = start.getFullYear() === end.getFullYear();
            if (sameYear) {
                if (start.getMonth() === end.getMonth()) {
                    return `${start.getDate()} – ${end.getDate()} ${MONTHS_GENITIVE[end.getMonth()]} ${end.getFullYear()}`;
                }
                return `${formatDateHuman(start)} – ${formatDateHuman(end)} ${end.getFullYear()}`;
            }
            return `${formatDateHuman(start)} ${start.getFullYear()} – ${formatDateHuman(end)} ${end.getFullYear()}`;
        };

        let currentOpen = null;
        let overlayEl = null;
        let overlayMouseDown = false;
        let ghostEl = null;

        const lockScrollBody = (on) => {
            document.documentElement.style.overflow = on ? "hidden" : "";
        };
        const ensureOverlay = () => {
            if (!overlayEl) {
                overlayEl = document.createElement("div");
                overlayEl.className = "exs-overlay";

                overlayEl.addEventListener("mousedown", () => {
                    overlayMouseDown = true;
                }, { capture: true });

                overlayEl.addEventListener("mouseup", () => {
                    if (overlayMouseDown) {
                        if (currentOpen) currentOpen.close();
                    }
                    overlayMouseDown = false;
                }, { capture: true });

                document.addEventListener("mouseup", (e) => {
                    if (e.target !== overlayEl) overlayMouseDown = false;
                }, { capture: true });

                document.body.appendChild(overlayEl);
            }
        };
        const moveOverlayOnTop = () => {
            if (overlayEl) {
                overlayEl.remove();
                document.body.appendChild(overlayEl);
            }
        };
        const removeOverlay = () => {
            if (overlayEl) {
                overlayEl.remove();
                overlayEl = null;
            }
            overlayMouseDown = false;
        };

        function sanitizeGhost(root) {
            root.querySelectorAll(".exs-hidden").forEach(n => n.remove());
            const removeJsClasses = (el) => {
                if (el.classList && el.classList.length) {
                    [...el.classList].forEach(cls => {
                        if (cls.startsWith("js-")) {
                            el.classList.remove(cls);
                        }
                    });
                }
            };
            removeJsClasses(root);
            root.querySelectorAll("*").forEach(el => removeJsClasses(el));
            root.querySelectorAll("input, select, textarea, button").forEach(el => {
                el.removeAttribute("name");
                el.setAttribute("disabled", "disabled");
                el.setAttribute("tabindex", "-1");
                el.removeAttribute("aria-controls");
                el.removeAttribute("aria-owns");
            });
            root.querySelectorAll("[id]").forEach(el => el.removeAttribute("id"));
            root.querySelectorAll(".exs-popover").forEach(p => p.setAttribute("hidden", ""));
            root.setAttribute("aria-hidden", "true");
        }
        function createGhost() {
            if (ghostEl) return;
            const bodyNode = filters.querySelector(".filters-body");
            if (!bodyNode) return;
            ghostEl = document.createElement("div");
            ghostEl.className = "filters-ghost";
            const clone = bodyNode.cloneNode(true);
            sanitizeGhost(clone);
            ghostEl.appendChild(clone);
            filters.parentNode.insertBefore(ghostEl, filters);
        }
        function removeGhost() {
            if (!ghostEl) return;
            ghostEl.remove();
            ghostEl = null;
        }

        function portalOpen(pop, trigger) {
            const placeholder = document.createComment("exs-portal-placeholder");
            pop.parentNode.insertBefore(placeholder, pop);
            document.body.appendChild(pop);

            let cleanupPos = () => {};
            if (!isMobile()) {
                const applyPos = () => {
                    const rect = trigger.getBoundingClientRect();
                    const style = pop.style;
                    style.position = "fixed";
                    style.top = (rect.bottom + 6) + "px";
                    style.width = rect.width + "px";
                    style.right = "auto";
                    style.bottom = "auto";
                    style.zIndex = 11000;
                    style.opacity = "1";
                    style.transform = "translateY(0)";

                    const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
                    const viewportPadding = 12;
                    const popWidth = pop.offsetWidth;
                    const maxLeft = viewportWidth - viewportPadding - popWidth;
                    let left = rect.left;
                    if (Number.isFinite(maxLeft)) {
                        left = Math.min(left, maxLeft);
                    }
                    if (left < viewportPadding) {
                        left = viewportPadding;
                    }
                    style.left = `${left}px`;
                };
                applyPos();
                const onScrollResize = () => applyPos();
                window.addEventListener("scroll", onScrollResize, true);
                window.addEventListener("resize", onScrollResize);
                cleanupPos = () => {
                    window.removeEventListener("scroll", onScrollResize, true);
                    window.removeEventListener("resize", onScrollResize);
                    const style = pop.style;
                    style.position = "";
                    style.left = "";
                    style.top = "";
                    style.width = "";
                    style.right = "";
                    style.bottom = "";
                    style.opacity = "";
                    style.transform = "";
                    style.transition = "";
                };
            }
            const restore = () => {
                cleanupPos();
                if (placeholder.parentNode) {
                    placeholder.parentNode.insertBefore(pop, placeholder);
                    placeholder.remove();
                }
            };
            return { restore };
        }

        function animateFromTo(pop, fromY, toY, duration = 180, easing = "ease", onEnd) {
            pop.style.animation = "";
            pop.dataset.open = "";
            pop.dataset.closing = "";
            pop.style.transition = "none";
            pop.style.transform = `translateY(${fromY}px)`;
            requestAnimationFrame(() => {
                pop.style.transition = `transform ${duration}ms ${easing}`;
                requestAnimationFrame(() => {
                    pop.style.transform = (typeof toY === "string") ? toY : `translateY(${toY}px)`;
                });
            });
            const handler = (e) => {
                if (e.propertyName !== "transform") return;
                pop.removeEventListener("transitionend", handler);
                pop.style.transition = "";
                onEnd && onEnd();
            };
            pop.addEventListener("transitionend", handler);
        }
        function startKeyframe(pop, kind ) {
            pop.style.animation = "";
            pop.style.transform = "";
            void pop.offsetWidth;
            if (kind === "open") {
                pop.dataset.closing = "";
                pop.dataset.open = "true";
            } else {
                pop.dataset.open = "";
                pop.dataset.closing = "true";
            }
        }
        function desktopFadeOut(pop, done) {
            pop.style.transition = "opacity 140ms ease, transform 140ms ease";
            let finished = false;
            const clear = () => {
                if (finished) return;
                finished = true;
                pop.style.transition = "";
                pop.style.opacity = "";
                pop.style.transform = "";
                done && done();
            };
            requestAnimationFrame(() => {
                pop.style.opacity = "0";
                pop.style.transform = "translateY(-4px)";
            });
            const onEnd = (e) => {
                if (e.target !== pop) return;
                pop.removeEventListener("transitionend", onEnd);
                clear();
            };
            pop.addEventListener("transitionend", onEnd);
            setTimeout(clear, 180);
        }

        const RUBBER_K = 160;
        const VSLACK = 40;
        const BASE_PULL = 125;
        const MAX_UP_ACTUAL = BASE_PULL * Math.exp(-VSLACK / RUBBER_K);
        function rubberUpShifted(pull) {
            const eV = Math.exp(-VSLACK / RUBBER_K);
            const val = BASE_PULL * eV * (1 - Math.exp(-pull / RUBBER_K));
            return Math.min(val, MAX_UP_ACTUAL);
        }

        function attachSwipe(pop, api) {
            if (!isMobile()) return () => {};

            const scrollable = pop.querySelector(".exs-body") || pop;
            const isSwipeLocked = (target) => Boolean(target && target.closest(".js-exs-swipe-lock"));
            const setSheetDragMeta = (active, distance = 0) => {
                if (active) {
                    pop.dataset.sheetDragging = "true";
                    if (distance > 0) {
                        pop.dataset.sheetDragDistance = String(distance);
                    } else {
                        delete pop.dataset.sheetDragDistance;
                    }
                } else {
                    delete pop.dataset.sheetDragging;
                    delete pop.dataset.sheetDragDistance;
                }
            };
            const updateSheetDragDistance = (distance) => {
                if (pop.dataset.sheetDragging === "true") {
                    if (distance > 0) {
                        pop.dataset.sheetDragDistance = String(distance);
                    } else {
                        delete pop.dataset.sheetDragDistance;
                    }
                }
            };
            const abortSwipeGesture = () => {
                started = false;
                dragging = false;
                dy = 0;
                if (rafId != null) {
                    cancelAnimationFrame(rafId);
                    rafId = null;
                }
                setSheetDragMeta(false);
            };

            let started = false, dragging = false;
            let y0 = 0, dy = 0, rafId = null;

            const THRESH = 6;
            const clampSheet = (y) => {
                const maxDown = window.innerHeight * 0.85;
                const minUp = -MAX_UP_ACTUAL;
                return Math.max(minUp, Math.min(y, maxDown));
            };
            const applyY = (y) => { pop.style.transform = `translateY(${clampSheet(y)}px)`; };
            const onFrame = () => { rafId = null; applyY(dy); };

            const tryStart = (clientY) => {
                started = true;
                dragging = false;
                y0 = clientY;
                dy = 0;
                pop.style.animation = "none";
                pop.dataset.open = "";
                pop.dataset.closing = "";
                pop.style.transition = "none";
                setSheetDragMeta(false);
            };

            const onMoveCore = (clientY, e) => {
                if (!started) return;
                const delta = clientY - y0;
                const distance = delta < 0 ? Math.max(0, -delta) : delta;

                if (!dragging) {
                    if (delta < -THRESH && scrollable.scrollTop <= 0) { dragging = true; setSheetDragMeta(true, distance); }
                    else if (delta > THRESH) { dragging = true; setSheetDragMeta(true, distance); }
                    else { return; }
                } else {
                    updateSheetDragDistance(distance);
                }

                if (delta < 0 && scrollable.scrollTop <= 0) {
                    const pull = Math.max(0, -delta);
                    dy = -rubberUpShifted(pull);
                    if (e && e.cancelable) e.preventDefault();
                    if (rafId == null) rafId = requestAnimationFrame(onFrame);
                    return;
                }

                if (delta >= 0) {
                    dy = delta;
                    if (e && e.cancelable) e.preventDefault();
                    if (rafId == null) rafId = requestAnimationFrame(onFrame);
                    return;
                }
            };

            const endCore = () => {
                if (!started) return;
                started = false;

                if (dragging) {
                    cancelAnimationFrame(rafId); rafId = null;

                    if (dy > 0) {
                        const threshold = 40;
                        const currentY = clampSheet(dy);
                        if (currentY > threshold) {
                            animateFromTo(pop, currentY, "translateY(100%)", 180, "ease", () => {
                                api.close({ animatedFromY: null, alreadyAnimated: true });
                            });
                        } else {
                            animateFromTo(pop, currentY, 0, 180, "ease", () => {
                                pop.style.transform = "";
                                pop.style.animation = "";
                            });
                        }
                    } else {
                        const currentY = clampSheet(dy);
                        animateFromTo(pop, currentY, 0, 160, "cubic-bezier(.2,.8,.2,1)", () => {
                            pop.style.transform = "";
                            pop.style.animation = "";
                        });
                    }
                }

                dragging = false;
                dy = 0;
                setSheetDragMeta(false);
            };

            pop.addEventListener("pointerdown", (e) => {
                if (e.pointerType !== "touch") {
                    return;
                }
                if (isSwipeLocked(e.target)) {
                    abortSwipeGesture();
                    return;
                }
                tryStart(e.clientY);
            }, { passive: true });
            pop.addEventListener("pointermove", (e) => onMoveCore(e.clientY, e), { passive: false });
            pop.addEventListener("pointerup", endCore, { passive: true });
            pop.addEventListener("pointercancel", endCore, { passive: true });

            pop.addEventListener("touchstart", (e) => {
                const touch = e.touches[0];
                if (!touch) {
                    return;
                }
                if (isSwipeLocked(e.target)) {
                    abortSwipeGesture();
                    return;
                }
                tryStart(touch.clientY);
            }, { passive: true });
            pop.addEventListener("touchmove", (e) => onMoveCore(e.touches[0].clientY, e), { passive: false });
            pop.addEventListener("touchend", endCore, { passive: true });
            pop.addEventListener("touchcancel", endCore, { passive: true });

            return () => {};
        }

        (function outsideClickOnly() {
            const handler = (e) => {
                if (!currentOpen) return;
                const { pop, root, trigger } = currentOpen;
                if (pop.contains(e.target) || root.contains(e.target) || trigger.contains(e.target)) return;
                currentOpen.close();
                e.stopPropagation();
            };
            document.addEventListener("click", handler, true);
        })();

        const extraSelectRegistry = new Map();
        const filtersOpenBadge = document.querySelector(".js-filters-open-badge");
        const standaloneChecks = [...document.querySelectorAll(".filters-extra-checks input[type=\"checkbox\"]")];

        const updateFiltersBadge = () => {
            if (!filtersOpenBadge) {
                return;
            }
            let count = 0;
            extraSelectRegistry.forEach((api) => {
                if (typeof api.isActive === "function" && api.isActive()) {
                    count += 1;
                }
            });
            standaloneChecks.forEach((checkbox) => {
                if (checkbox.checked) {
                    count += 1;
                }
            });
            filtersOpenBadge.textContent = String(count);
            filtersOpenBadge.classList.toggle("is-visible", count > 0);
        };

        standaloneChecks.forEach((checkbox) => {
            checkbox.addEventListener("change", () => {
                updateFiltersBadge();
            });
        });

        const roots = document.querySelectorAll(".js-extra-select");
        if (!roots.length) {
            updateFiltersBadge();
            return;
        }

        roots.forEach((root) => {
            const type = (root.dataset.type || "checkbox").trim();
            const field = (root.dataset.field || "").trim();
            const placeholder = (root.dataset.placeholder || "Выбрать…").trim();
            const maxChars = +root.dataset.maxLabelChars || 28;

            const btn = root.querySelector(".js-exs-trigger");
            const pop = document.getElementById("exs-popover-" + field);
            const body = root.querySelector(".js-exs-body") || (pop ? pop.querySelector(".js-exs-body") : null);
            const hiddenWrap = root.querySelector(".js-exs-hidden");
            const closeX = pop ? pop.querySelector(".js-exs-close") : null;
            const datesInput = pop ? pop.querySelector(".js-dates-input") : null;
            const datesCalendarWrap = pop ? pop.querySelector(".js-dates-picker") : null;

            let applied = [];
            let detachSwipe = null;
            let portalRestore = null;
            let hasActive = false;
            let defaultRadioValue = "";

            const setButtonText = (text) => {
                if (!btn) return;
                const labelHolder = btn.querySelector("[data-trigger-label]");
                if (labelHolder) {
                    labelHolder.textContent = text;
                } else {
                    btn.textContent = text;
                }
            };

            const makeLabel = (arr, maxChars) => {
                if (!arr.length) return "";
                let out = "";
                for (let i = 0; i < arr.length; i++) {
                    const next = (out ? out + ", " : "") + arr[i];
                    if (next.length > maxChars) return out ? (out + ", …") : "…";
                    out = next;
                }
                return out;
            };

            const updateBtn = () => {
                if (!btn) return;

                let nextActive = false;

                if (type === "checkbox") {
                    if (!applied.length) {
                        setButtonText(placeholder);
                        btn.classList.remove("is-active");
                        root.classList.remove("is-filled");
                    } else {
                        setButtonText(makeLabel(applied, maxChars));
                        btn.classList.add("is-active");
                        root.classList.add("is-filled");
                        nextActive = true;
                    }
                } else if (type === "range") {
                    const min = Number(root.dataset.min ?? "0");
                    const max = Number(root.dataset.max ?? "0");
                    if (!applied.length || (applied[0] === "" && applied[1] === "")) {
                        setButtonText(placeholder);
                        btn.classList.remove("is-active");
                        root.classList.remove("is-filled");
                    } else {
                        const [aRaw, bRaw] = applied;
                        const a = aRaw === "" ? min : Number(aRaw);
                        const b = bRaw === "" ? max : Number(bRaw);
                        if (a === min && b === max) {
                            setButtonText(placeholder);
                            btn.classList.remove("is-active");
                            root.classList.remove("is-filled");
                        } else {
                            let text = "";
                            if (a !== min && b !== max) text = `${a} – ${b}`;
                            else if (a !== min)         text = `от ${a}`;
                            else if (b !== max)         text = `до ${b}`;
                            setButtonText(text || placeholder);
                            if (text) {
                                btn.classList.add("is-active");
                                root.classList.add("is-filled");
                                nextActive = true;
                            } else {
                                btn.classList.remove("is-active");
                                root.classList.remove("is-filled");
                            }
                        }
                    }
                } else if (type === "dates") {
                    if (!applied.length || !applied[0] || !applied[1]) {
                        setButtonText(placeholder);
                        btn.classList.remove("is-active");
                        root.classList.remove("is-filled");
                        if (datesInput) {
                            datesInput.dataset.datespickerValue = "";
                            datesInput.value = "";
                        }
                    } else {
                        const startDate = parseISODate(applied[0]);
                        const endDate = parseISODate(applied[1]);
                        if (startDate && endDate) {
                            const label = formatRangeHuman(startDate, endDate) || placeholder;
                            setButtonText(label);
                            if (label && label !== placeholder) {
                                btn.classList.add("is-active");
                                root.classList.add("is-filled");
                                nextActive = true;
                            } else {
                                btn.classList.remove("is-active");
                                root.classList.remove("is-filled");
                            }
                            if (datesInput) {
                                const isoRange = `${toISODate(startDate)} – ${toISODate(endDate)}`;
                                datesInput.dataset.datespickerValue = isoRange;
                                datesInput.value = label;
                            }
                        } else {
                            setButtonText(placeholder);
                            btn.classList.remove("is-active");
                            root.classList.remove("is-filled");
                            if (datesInput) {
                                datesInput.dataset.datespickerValue = "";
                                datesInput.value = "";
                            }
                        }
                    }
                } else if (type === "radio") {
                    const radios = pop ? [...pop.querySelectorAll('input[type="radio"]')] : [];
                    let val = "";
                    const h = hiddenWrap ? hiddenWrap.querySelector('input[type="hidden"][name="sort"]') : null;
                    if (h && h.value) {
                        val = h.value;
                    } else {
                        const ch = radios.find(r => r.checked);
                        if (ch) val = ch.value;
                    }
                    const current = radios.find(r => r.value === val) || radios[0];
                    const labelText =
                        (current?.dataset?.label || "").trim() ||
                        current?.closest("label")?.textContent?.trim() ||
                        current?.value || "";
                    setButtonText(labelText || placeholder);
                    btn.classList.add("is-active");
                    nextActive = Boolean(current?.value) && current.value !== defaultRadioValue;
                    root.classList.remove("is-filled");
                } else if (type === "stub") {
                    setButtonText(placeholder);
                    root.classList.remove("is-filled");
                } else {
                    root.classList.remove("is-filled");
                }
                hasActive = nextActive;
                updateFiltersBadge();
            };

            const writeHidden = () => {
                if (!hiddenWrap) return;

                if (type === "checkbox") {
                    hiddenWrap.innerHTML = "";
                    applied.forEach(v => {
                        const h = document.createElement("input");
                        h.type = "hidden";
                        h.name = field + "[]";
                        h.value = v;
                        hiddenWrap.appendChild(h);
                    });
                    return;
                }

                if (type === "range") {
                    hiddenWrap.innerHTML = "";
                    const h1 = document.createElement("input");
                    h1.type = "hidden";
                    h1.name = field + "[min]";
                    h1.value = applied[0] ?? "";
                    const h2 = document.createElement("input");
                    h2.type = "hidden";
                    h2.name = field + "[max]";
                    h2.value = applied[1] ?? "";
                    hiddenWrap.appendChild(h1);
                    hiddenWrap.appendChild(h2);
                    return;
                }

                if (type === "dates") {
                    hiddenWrap.innerHTML = "";
                    const h1 = document.createElement("input");
                    h1.type = "hidden";
                    h1.name = field + "[start]";
                    h1.value = applied[0] ?? "";
                    const h2 = document.createElement("input");
                    h2.type = "hidden";
                    h2.name = field + "[end]";
                    h2.value = applied[1] ?? "";
                    hiddenWrap.appendChild(h1);
                    hiddenWrap.appendChild(h2);
                    return;
                }

                if (type === "radio") {
                    const h = hiddenWrap.querySelector('input[type="hidden"][name="sort"]');
                    if (h) h.value = applied[0] ?? h.value ?? "";
                    return;
                }
            };

            const readHidden = () => {
                if (!hiddenWrap) { applied = []; return; }

                if (type === "checkbox") {
                    applied = [...hiddenWrap.querySelectorAll(`input[type="hidden"][name="${field}[]"]`)].map(h => h.value);
                    return;
                }

                if (type === "range") {
                    const h1 = hiddenWrap.querySelector(`input[type="hidden"][name="${field}[min]"]`);
                    const h2 = hiddenWrap.querySelector(`input[type="hidden"][name="${field}[max]"]`);
                    applied = [(h1?.value ?? ""), (h2?.value ?? "")];
                    return;
                }

                if (type === "dates") {
                    const h1 = hiddenWrap.querySelector(`input[type="hidden"][name="${field}[start]"]`);
                    const h2 = hiddenWrap.querySelector(`input[type="hidden"][name="${field}[end]"]`);
                    applied = [(h1?.value ?? ""), (h2?.value ?? "")];
                    return;
                }
                if (type === "radio") {
                    const radios = pop ? [...pop.querySelectorAll('input[type="radio"]')] : [];
                    const h = hiddenWrap.querySelector(`input[type="hidden"][name="sort"]`);
                    let v = (h?.value || "");
                    if (!v) {
                        const ch = radios.find(r => r.checked);
                        if (ch) v = ch.value;
                    }
                    applied = [v];
                    return;
                }

                if (type === "stub") {
                    applied = [];
                }
            };

            if (type === "checkbox") {
                const checks = body ? [...body.querySelectorAll('input[type="checkbox"]')] : [];

                const syncChecksFromApplied = () => {
                    const set = new Set(applied);
                    checks.forEach(c => { c.checked = set.has(c.value); });
                };

                const commitFromChecks = () => {
                    applied = checks.filter(c => c.checked).map(c => c.value);
                    writeHidden();
                    updateBtn();
                };

                const resetChecks = () => {
                    checks.forEach(c => { c.checked = false; });
                    applied = [];
                    writeHidden();
                    updateBtn();
                };

                const open = () => {
                    if (currentOpen && currentOpen.root !== root) currentOpen.close();
                    syncChecksFromApplied();
                    if (pop) { pop.hidden = false; btn.setAttribute("aria-expanded", "true"); }
                    const { restore } = portalOpen(pop, btn);
                    portalRestore = restore;
                    ensureOverlay(); moveOverlayOnTop(); lockScrollBody(true);
                    if (isMobile()) {
                        startKeyframe(pop, "open");
                        detachSwipe = attachSwipe(pop, api);
                    }
                    currentOpen = { root, pop, trigger: btn, close: api.close };
                    (checks.find(x => x.checked) || checks[0])?.focus();
                };

                const reallyHide = () => { if (pop) pop.hidden = true; };

                const close = (opts = {}) => {
                    const { animatedFromY = null, alreadyAnimated = false } = opts;

                    const finalize = () => {
                        removeOverlay(); lockScrollBody(false);
                        reallyHide();
                        if (portalRestore) { portalRestore(); portalRestore = null; }
                        btn.setAttribute("aria-expanded", "false");
                        if (currentOpen && currentOpen.root === root) currentOpen = null;
                    };

                    if (detachSwipe) { detachSwipe(); detachSwipe = null; }

                    if (isMobile()) {
                        if (alreadyAnimated) {
                            finalize();
                        } else if (Number.isFinite(animatedFromY) && animatedFromY > 0) {
                            animateFromTo(pop, animatedFromY, "translateY(100%)", 180, "ease", finalize);
                        } else {
                            startKeyframe(pop, "close");
                            setTimeout(finalize, 180);
                        }
                        setTimeout(() => { pop.style.transform = ""; pop.style.animation = ""; }, 200);
                    } else {
                        desktopFadeOut(pop, finalize);
                    }
                };

                const trapFocus = (e) => {
                    if (e.key !== "Tab") return;
                    const f = pop.querySelectorAll("input,button,[tabindex]:not([tabindex='-1'])");
                    if (!f.length) return;
                    const first = f[0], last = f[f.length - 1];
                    if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
                    else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
                };
                const onArrows = (e) => {
                    if (e.key !== "ArrowDown" && e.key !== "ArrowUp") return;
                    const list = checks; const i = list.indexOf(document.activeElement);
                    if (i === -1) return; e.preventDefault();
                    const next = e.key === "ArrowDown" ? Math.min(i + 1, list.length - 1) : Math.max(i - 1, 0);
                    list[next].focus();
                };

                ["pointerdown", "mousedown", "touchstart", "click"].forEach(ev => {
                    pop.addEventListener(ev, (ev2) => ev2.stopPropagation(), { passive: ev === "touchstart" });
                });

                btn.addEventListener("click", (e) => { e.stopPropagation(); (pop.hidden ? open : api.close)(); });
                btn.addEventListener("keydown", (e) => { if (e.key === "Enter" || e.key === " ") { e.preventDefault(); (pop.hidden ? open : api.close)(); } });
                pop.addEventListener("keydown", trapFocus);
                pop.addEventListener("keydown", (e) => { if (e.key === "Escape") { e.stopPropagation(); api.close(); } });
                pop.addEventListener("keydown", onArrows);
                closeX?.addEventListener("click", () => api.close());

                pop.addEventListener("click", (e) => {
                    const action = e.target?.dataset?.action;
                    if (action === "reset") {
                        resetChecks();
                        root.dispatchEvent(new CustomEvent("exs-apply", { detail: { field: field, values: applied } }));
                        api.close();
                        submitAjax();
                    }
                    if (action === "apply") {
                        commitFromChecks();
                        root.dispatchEvent(new CustomEvent("exs-apply", { detail: { field: field, values: applied } }));
                        api.close();
                        submitAjax();
                    }
                });

                readHidden();
                if (!applied.length) {
                    const pre = checks.filter(c => c.checked).map(c => c.value);
                    if (pre.length) {
                        applied = pre;
                        writeHidden();
                    }
                }
                syncChecksFromApplied();
                updateBtn();

                var api = { root, pop, trigger: btn, close };
                extraSelectRegistry.set(root, {
                    field,
                    type,
                    commitFromUi: commitFromChecks,
                    resetForAll: resetChecks,
                    isActive: () => hasActive
                });

            } else if (type === "dates") {
                const today = clampToDate(new Date());
                const minViewDate = startOfMonth(today);
                let stagedDates = [null, null];
                let viewDate = minViewDate;
                let hoverDate = null;
                let hasReadInitialDataset = false;
                const skipClickByIso = new Map();
                const SKIP_CLICK_WINDOW_MS = 1200;

                const armSkipForIso = (isoValue) => {
                    const existing = skipClickByIso.get(isoValue);
                    if (existing != null) {
                        clearTimeout(existing);
                    }
                    const timerId = setTimeout(() => {
                        if (skipClickByIso.get(isoValue) === timerId) {
                            skipClickByIso.delete(isoValue);
                        }
                    }, SKIP_CLICK_WINDOW_MS);
                    skipClickByIso.set(isoValue, timerId);
                };

                const clearSkipForIso = (isoValue) => {
                    const timerId = skipClickByIso.get(isoValue);
                    if (timerId != null) {
                        clearTimeout(timerId);
                        skipClickByIso.delete(isoValue);
                    }
                };

                const shouldSkipClickForIso = (isoValue) => skipClickByIso.has(isoValue);

                const isDateInPast = (date) => {
                    if (!(date instanceof Date)) return false;
                    return date.getTime() < today.getTime();
                };

                const updateDisplayFromStaged = () => {
                    if (!datesInput) return;
                    const startSel = stagedDates[0];
                    const endSel = stagedDates[1];
                    if (startSel && endSel) {
                        let a = clampToDate(startSel);
                        let b = clampToDate(endSel);
                        if (b.getTime() < a.getTime()) [a, b] = [b, a];
                        const isoRange = `${toISODate(a)} – ${toISODate(b)}`;
                        datesInput.dataset.datespickerValue = isoRange;
                        datesInput.value = formatRangeHuman(a, b);
                    } else if (startSel) {
                        const a = clampToDate(startSel);
                        const isoRange = toISODate(a);
                        datesInput.dataset.datespickerValue = isoRange;
                        datesInput.value = `${formatDateHuman(a)} ${a.getFullYear()}`;
                    } else {
                        datesInput.dataset.datespickerValue = "";
                        datesInput.value = "";
                    }
                };

                const setStagedFromApplied = () => {
                    let start = parseISODate(applied[0] ?? "");
                    let end = parseISODate(applied[1] ?? "");
                    if (!hasReadInitialDataset && (!start || !end) && datesInput) {
                        const raw = (datesInput.dataset.datespickerValue || "").split("–").map(part => part.trim());
                        if (!start && raw[0]) start = parseISODate(raw[0]);
                        if (!end && raw[1]) end = parseISODate(raw[1]);
                    }
                    start = start ? clampToDate(start) : null;
                    end = end ? clampToDate(end) : null;
                    if (start && end && end.getTime() < start.getTime()) {
                        [start, end] = [end, start];
                    }
                    if (start && end) {
                        stagedDates = [start, end];
                    } else if (start) {
                        stagedDates = [start, null];
                    } else if (end) {
                        stagedDates = [end, null];
                    } else {
                        stagedDates = [null, null];
                    }
                    hoverDate = null;
                    const nextView = stagedDates[0] ? startOfMonth(stagedDates[0]) : minViewDate;
                    viewDate = nextView.getTime() < minViewDate.getTime() ? minViewDate : nextView;
                    hasReadInitialDataset = true;
                    updateDisplayFromStaged();
                };

                const handleDaySelection = (isoValue) => {
                    const nextDate = parseISODate(isoValue);
                    if (!nextDate) return;
                    const normalized = clampToDate(nextDate);
                    if (isDateInPast(normalized)) return;
                    const startSel = stagedDates[0];
                    const endSel = stagedDates[1];
                    if (!startSel || (startSel && endSel)) {
                        stagedDates = [normalized, null];
                    } else {
                        if (normalized.getTime() < startSel.getTime()) {
                            stagedDates = [normalized, startSel];
                        } else if (isSameDay(normalized, startSel)) {
                            stagedDates = [normalized, normalized];
                        } else {
                            stagedDates = [startSel, normalized];
                        }
                    }
                    hoverDate = null;
                    updateDisplayFromStaged();
                    renderCalendar();
                };

                const renderMonth = (baseDate, addClass = '') => {
                    const monthEl = document.createElement("div");
                    monthEl.className = "datespicker-month " + addClass;

                    const title = document.createElement("div");
                    title.className = "datespicker-month-name";
                    title.textContent = formatMonthTitle(baseDate);
                    monthEl.appendChild(title);

                    const weekdaysRow = document.createElement("div");
                    weekdaysRow.className = "datespicker-weekdays";
                    WEEKDAYS_SHORT.forEach((name) => {
                        const cell = document.createElement("div");
                        cell.className = "datespicker-weekday";
                        cell.textContent = name;
                        weekdaysRow.appendChild(cell);
                    });
                    monthEl.appendChild(weekdaysRow);

                    const grid = document.createElement("div");
                    grid.className = "datespicker-grid";

                    const firstDay = startOfMonth(baseDate);
                    const offset = (firstDay.getDay() + 6) % 7;
                    let cursor = addDays(firstDay, -offset);

                    const startSel = stagedDates[0];
                    const endSel = stagedDates[1];
                    const previewEnd = (!endSel && startSel && hoverDate) ? clampToDate(hoverDate) : endSel;
                    const rangeStart = startSel ? clampToDate(startSel) : null;
                    const rangeEnd = rangeStart ? clampToDate(previewEnd || rangeStart) : null;

                    const addDayHandlers = (btnDay, isoValue) => {
                        const selectDate = () => {
                            handleDaySelection(isoValue);
                        };

                        const handleTouchLike = () => {
                            if (btnDay.disabled) {
                                return;
                            }
                            armSkipForIso(isoValue);
                            selectDate();
                        };

                        btnDay.addEventListener("click", () => {
                            if (shouldSkipClickForIso(isoValue)) {
                                clearSkipForIso(isoValue);
                                return;
                            }
                            clearSkipForIso(isoValue);
                            selectDate();
                        });

                        const canUsePointer = typeof window !== "undefined" && window.PointerEvent;

                        if (canUsePointer) {
                            let pendingTouchPointerId = null;
                            let pendingTouchStart = null;
                            let pointerMoveExceeded = false;
                            let removePendingMoveListener = null;
                            const TAP_DRAG_CANCEL_PX = 32;
                            const SHEET_DRAG_CANCEL_PX = 24;
                            const detachGlobalMove = () => {
                                if (removePendingMoveListener) {
                                    removePendingMoveListener();
                                    removePendingMoveListener = null;
                                }
                            };

                            btnDay.addEventListener("pointerdown", (e) => {
                                if (e.pointerType === "mouse") {
                                    return;
                                }
                                detachGlobalMove();
                                pendingTouchPointerId = e.pointerId;
                                pendingTouchStart = { x: e.clientX, y: e.clientY };
                                pointerMoveExceeded = false;
                                const onGlobalMove = (moveEvent) => {
                                    if (moveEvent.pointerId !== pendingTouchPointerId) {
                                        return;
                                    }
                                    if (moveEvent.pointerType === "mouse" || !pendingTouchStart) {
                                        return;
                                    }
                                    const dx = Math.abs(moveEvent.clientX - pendingTouchStart.x);
                                    const dy = Math.abs(moveEvent.clientY - pendingTouchStart.y);
                                    if (dx > TAP_DRAG_CANCEL_PX || dy > TAP_DRAG_CANCEL_PX) {
                                        pointerMoveExceeded = true;
                                    }
                                };
                                window.addEventListener("pointermove", onGlobalMove, { passive: true });
                                removePendingMoveListener = () => {
                                    window.removeEventListener("pointermove", onGlobalMove);
                                };
                            });

                            btnDay.addEventListener("pointerup", (e) => {
                                if (e.pointerType === "mouse") {
                                    return;
                                }
                                if (pendingTouchPointerId !== e.pointerId) {
                                    return;
                                }
                                detachGlobalMove();
                                const startPoint = pendingTouchStart;
                                pendingTouchStart = null;
                                const totalDx = startPoint ? Math.abs(e.clientX - startPoint.x) : 0;
                                const totalDy = startPoint ? Math.abs(e.clientY - startPoint.y) : 0;
                                if (totalDx > TAP_DRAG_CANCEL_PX || totalDy > TAP_DRAG_CANCEL_PX) {
                                    pointerMoveExceeded = true;
                                }
                                pendingTouchPointerId = null;
                                const popRoot = btnDay.closest(".exs-popover");
                                let shouldSkipForSheetDrag = false;
                                if (popRoot && popRoot.dataset.sheetDragging === "true") {
                                    const distance = Number(popRoot.dataset.sheetDragDistance || "0");
                                    if (Number.isFinite(distance) && distance > SHEET_DRAG_CANCEL_PX) {
                                        shouldSkipForSheetDrag = true;
                                    }
                                }
                                const fingerMovedFar = pointerMoveExceeded;
                                pointerMoveExceeded = false;
                                if (shouldSkipForSheetDrag || fingerMovedFar) {
                                    armSkipForIso(isoValue);
                                    setTimeout(() => { clearSkipForIso(isoValue); }, 300);
                                    return;
                                }
                                handleTouchLike();
                            });

                            btnDay.addEventListener("pointercancel", (e) => {
                                if (e.pointerType === "mouse") {
                                    return;
                                }
                                if (pendingTouchPointerId === e.pointerId) {
                                    pendingTouchPointerId = null;
                                    pendingTouchStart = null;
                                    pointerMoveExceeded = false;
                                    detachGlobalMove();
                                }
                            });
                        } else {
                            let touchStarted = false;

                            btnDay.addEventListener("touchstart", () => {
                                touchStarted = true;
                            }, { passive: true });

                            btnDay.addEventListener("touchend", () => {
                                if (!touchStarted) {
                                    return;
                                }
                                touchStarted = false;
                                handleTouchLike();
                            });

                            btnDay.addEventListener("touchcancel", () => {
                                touchStarted = false;
                            }, { passive: true });
                        }
                    };

                    for (let i = 0; i < 42; i++) {
                        const cellDate = cursor;
                        const isoValue = toISODate(cellDate);
                        const btnDay = document.createElement("button");
                        btnDay.type = "button";
                        btnDay.className = "datespicker-day";
                        btnDay.textContent = String(cellDate.getDate());
                        if (cellDate.getMonth() !== baseDate.getMonth()) {
                            btnDay.classList.add("is-outside");
                        }
                        if (isSameDay(cellDate, today)) {
                            btnDay.classList.add("is-today");
                        }
                        const isPast = isDateInPast(cellDate);
                        if (isPast) {
                            btnDay.classList.add("is-disabled");
                            btnDay.disabled = true;
                        }
                        if (rangeStart) {
                            if (isDayBetween(cellDate, rangeStart, rangeEnd)) {
                                btnDay.classList.add("is-range");
                                if (isDayBetween(addDays(cellDate, -1), rangeStart, rangeEnd)) {
                                    btnDay.classList.add("is-to-left");
                                }
                                if (isDayBetween(addDays(cellDate, 1), rangeStart, rangeEnd)) {
                                    btnDay.classList.add("is-to-right");
                                }
                            }
                            if (isSameDay(cellDate, rangeStart)) {
                                btnDay.classList.add("is-range-start");
                            }
                            if (rangeEnd && isSameDay(cellDate, rangeEnd)) {
                                btnDay.classList.add("is-range-end");
                            }
                        }
                        if (!isPast) {
                            addDayHandlers(btnDay, isoValue);
                            btnDay.addEventListener("mouseenter", () => {
                                if (!stagedDates[0] || stagedDates[1]) return;
                                const nextHover = clampToDate(cellDate);
                                if (isDateInPast(nextHover)) return;
                                if (hoverDate && isSameDay(nextHover, hoverDate)) return;
                                hoverDate = nextHover;
                                renderCalendar();
                            });
                        }
                        grid.appendChild(btnDay);
                        cursor = addDays(cursor, 1);
                    }

                    monthEl.appendChild(grid);
                    return monthEl;
                };

                const renderCalendar = () => {
                    if (!datesCalendarWrap) return;
                    datesCalendarWrap.innerHTML = "";
                    const datespickerRoot = document.createElement("div");
                    datespickerRoot.className = "datespicker";

                    const nav = document.createElement("div");
                    nav.className = "datespicker-nav";

                    const prevBtn = document.createElement("button");
                    prevBtn.type = "button";
                    prevBtn.className = "datespicker-nav-btn datespicker-nav-btn_prev";
                    prevBtn.setAttribute("aria-label", "Предыдущий месяц");
                    prevBtn.textContent = "";
                    const prevTarget = addMonths(viewDate, -1);
                    const canGoPrev = prevTarget.getTime() >= minViewDate.getTime();
                    if (!canGoPrev) {
                        prevBtn.disabled = true;
                    } else {
                        prevBtn.addEventListener("click", () => {
                            const host = pop.querySelector(".datespicker-calendars");
                            const fromH = host ? host.offsetHeight : 0;

                            const nextView = addMonths(viewDate, -1);
                            viewDate = nextView.getTime() < minViewDate.getTime() ? minViewDate : nextView;

                            renderCalendar();

                            const newHost = pop.querySelector(".datespicker-calendars");
                            if (newHost) {
                                const toH = newHost.offsetHeight;

                                newHost.style.height = fromH + "px";
                                newHost.style.overflow = "hidden";
                                void newHost.getBoundingClientRect();

                                newHost.style.transition = "height 180ms ease";
                                requestAnimationFrame(() => {
                                    newHost.style.height = toH + "px";
                                });

                                newHost.addEventListener("transitionend", () => {
                                    newHost.style.height = "";
                                    newHost.style.transition = "";
                                    newHost.style.overflow = "";
                                }, { once: true });
                            }
                        });
                    }

                    const nextBtn = document.createElement("button");
                    nextBtn.type = "button";
                    nextBtn.className = "datespicker-nav-btn datespicker-nav-btn_next";
                    nextBtn.setAttribute("aria-label", "Следующий месяц");
                    nextBtn.textContent = "";
                    nextBtn.addEventListener("click", () => {
                        const host = pop.querySelector(".datespicker-calendars");
                        const fromH = host ? host.offsetHeight : 0;

                        viewDate = addMonths(viewDate, 1);

                        renderCalendar();

                        const newHost = pop.querySelector(".datespicker-calendars");
                        if (newHost) {
                            const toH = newHost.offsetHeight;

                            newHost.style.height = fromH + "px";
                            newHost.style.overflow = "hidden";
                            void newHost.getBoundingClientRect();

                            newHost.style.transition = "height 180ms ease";
                            requestAnimationFrame(() => {
                                newHost.style.height = toH + "px";
                            });

                            newHost.addEventListener("transitionend", () => {
                                newHost.style.height = "";
                                newHost.style.transition = "";
                                newHost.style.overflow = "";
                            }, { once: true });
                        }
                    });

                    const title = document.createElement("div");
                    title.className = "datespicker-nav-title";
                    const nextMonth = addMonths(viewDate, 1);
                    title.textContent = `${formatMonthTitle(viewDate)} – ${formatMonthTitle(nextMonth)}`;

                    nav.appendChild(prevBtn);
                    nav.appendChild(title);
                    nav.appendChild(nextBtn);
                    datespickerRoot.appendChild(nav);

                    const calendarsWrap = document.createElement("div");
                    calendarsWrap.className = "datespicker-calendars";
                    calendarsWrap.appendChild(renderMonth(viewDate, 'datespicker-month_left'));
                    calendarsWrap.appendChild(renderMonth(nextMonth, 'datespicker-month_right'));
                    datespickerRoot.appendChild(calendarsWrap);

                    calendarsWrap.addEventListener("mouseleave", () => {
                        if (!stagedDates[0] || stagedDates[1] || !hoverDate) return;
                        hoverDate = null;
                        renderCalendar();
                    });

                    datesCalendarWrap.appendChild(datespickerRoot);
                };

                const commitDates = () => {
                    const startSel = stagedDates[0];
                    const endCandidate = stagedDates[1] ?? stagedDates[0];
                    if (startSel && endCandidate) {
                        let a = clampToDate(startSel);
                        let b = clampToDate(endCandidate);
                        if (b.getTime() < a.getTime()) [a, b] = [b, a];
                        applied = [toISODate(a), toISODate(b)];
                    } else {
                        applied = ["", ""];
                    }
                    writeHidden();
                    updateBtn();
                    setStagedFromApplied();
                    renderCalendar();
                };

                const resetDates = () => {
                    applied = ["", ""];
                    stagedDates = [null, null];
                    hoverDate = null;
                    viewDate = minViewDate;
                    if (datesInput) {
                        datesInput.dataset.datespickerValue = "";
                        datesInput.value = "";
                    }
                    writeHidden();
                    updateBtn();
                    updateDisplayFromStaged();
                    renderCalendar();
                };

                const open = () => {
                    if (currentOpen && currentOpen.root !== root) currentOpen.close();
                    setStagedFromApplied();
                    renderCalendar();
                    if (pop) { pop.hidden = false; btn.setAttribute("aria-expanded", "true"); }
                    const { restore } = portalOpen(pop, btn);
                    portalRestore = restore;
                    ensureOverlay(); moveOverlayOnTop(); lockScrollBody(true);
                    if (isMobile()) {
                        startKeyframe(pop, "open");
                        detachSwipe = attachSwipe(pop, api);
                    }
                    currentOpen = { root, pop, trigger: btn, close: api.close };
                };

                const reallyHide = () => { if (pop) pop.hidden = true; };

                const close = (opts = {}) => {
                    const { animatedFromY = null, alreadyAnimated = false } = opts;

                    const finalize = () => {
                        removeOverlay(); lockScrollBody(false);
                        reallyHide();
                        if (portalRestore) { portalRestore(); portalRestore = null; }
                        btn.setAttribute("aria-expanded", "false");
                        if (currentOpen && currentOpen.root === root) currentOpen = null;
                    };

                    if (detachSwipe) { detachSwipe(); detachSwipe = null; }

                    if (isMobile()) {
                        if (alreadyAnimated) {
                            finalize();
                        } else if (Number.isFinite(animatedFromY) && animatedFromY > 0) {
                            animateFromTo(pop, animatedFromY, "translateY(100%)", 180, "ease", finalize);
                        } else {
                            startKeyframe(pop, "close");
                            setTimeout(finalize, 180);
                        }
                        setTimeout(() => { pop.style.transform = ""; pop.style.animation = ""; }, 200);
                    } else {
                        desktopFadeOut(pop, finalize);
                    }
                };

                const trapFocus = (e) => {
                    if (e.key !== "Tab") return;
                    const focusables = pop.querySelectorAll("button, input, [tabindex]:not([tabindex='-1'])");
                    if (!focusables.length) return;
                    const first = focusables[0];
                    const last = focusables[focusables.length - 1];
                    if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
                    else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
                };

                ["pointerdown", "mousedown", "touchstart", "click"].forEach(ev => {
                    pop.addEventListener(ev, (ev2) => ev2.stopPropagation(), { passive: ev === "touchstart" });
                });

                btn.addEventListener("click", (e) => { e.stopPropagation(); (pop.hidden ? open : api.close)(); });
                btn.addEventListener("keydown", (e) => { if (e.key === "Enter" || e.key === " ") { e.preventDefault(); (pop.hidden ? open : api.close)(); } });
                pop.addEventListener("keydown", trapFocus);
                pop.addEventListener("keydown", (e) => { if (e.key === "Escape") { e.stopPropagation(); api.close(); } });
                closeX?.addEventListener("click", () => api.close());

                pop.addEventListener("click", (e) => {
                    const action = e.target?.dataset?.action;
                    if (action === "reset") {
                        resetDates();
                        root.dispatchEvent(new CustomEvent("exs-apply", { detail: { field: field, values: applied } }));
                        api.close();
                        submitAjax();
                    }
                    if (action === "apply") {
                        commitDates();
                        root.dispatchEvent(new CustomEvent("exs-apply", { detail: { field: field, values: applied } }));
                        api.close();
                        submitAjax();
                    }
                });

                readHidden();
                if ((!applied[0] || !applied[1]) && datesInput?.dataset?.datespickerValue) {
                    const parts = datesInput.dataset.datespickerValue.split("–").map(part => part.trim());
                    if (parts.length === 2) {
                        const start = parseISODate(parts[0]);
                        const end = parseISODate(parts[1]);
                        if (start && end) {
                            applied = [toISODate(start), toISODate(end)];
                            writeHidden();
                        }
                    }
                }
                setStagedFromApplied();
                updateBtn();

                var api = { root, pop, trigger: btn, close };
                extraSelectRegistry.set(root, {
                    field,
                    type,
                    commitFromUi: commitDates,
                    resetForAll: resetDates,
                    isActive: () => hasActive
                });

            } else if (type === "range") {
                const min = +root.dataset.min || 0;
                const max = +root.dataset.max || 100;
                const step = +root.dataset.step || 1;

                const fromNum = pop.querySelector(".js-exs-from");
                const toNum = pop.querySelector(".js-exs-to");
                const pluginEl = pop.querySelector(".js-exs-range");

                const clamp = (v) => Math.min(max, Math.max(min, v));

                noUiSlider.create(pluginEl, {
                    start: [min, max],
                    connect: true,
                    step: step,
                    range: { min: min, max: max },
                    behaviour: "drag",
                    keyboardSupport: true
                });

                let staged = [min, max];

                const setStagedFromApplied = () => {
                    let a = applied[0] === "" ? min : clamp(+applied[0]);
                    let b = applied[1] === "" ? max : clamp(+applied[1]);
                    if (a > b) [a, b] = [b, a];
                    staged = [a, b];
                    pluginEl.noUiSlider.set(staged);
                    fromNum.value = a;
                    toNum.value = b;
                };

                const commitRange = () => {
                    const a = clamp(+fromNum.value);
                    const b = clamp(+toNum.value);
                    const lo = Math.min(a, b);
                    const hi = Math.max(a, b);
                    applied = [String(lo), String(hi)];
                    pluginEl.noUiSlider.set([lo, hi]);
                    staged = [lo, hi];
                    fromNum.value = lo;
                    toNum.value = hi;
                    writeHidden();
                    updateBtn();
                };

                const resetRange = () => {
                    applied = [String(min), String(max)];
                    pluginEl.noUiSlider.set([min, max]);
                    staged = [min, max];
                    fromNum.value = min;
                    toNum.value = max;
                    writeHidden();
                    updateBtn();
                };

                pluginEl.noUiSlider.on("update", (values) => {
                    const a = Math.round(values[0]); const b = Math.round(values[1]);
                    staged = [a, b];
                    if (document.activeElement !== fromNum) fromNum.value = a;
                    if (document.activeElement !== toNum) toNum.value = b;
                });

                const syncFrom = () => {
                    let v = clamp(+fromNum.value);
                    let other = staged[1];
                    if (v > other) other = v;
                    pluginEl.noUiSlider.set([v, other]); staged = [v, other];
                };
                const syncTo = () => {
                    let v = clamp(+toNum.value);
                    let other = staged[0];
                    if (v < other) other = v;
                    pluginEl.noUiSlider.set([other, v]); staged = [other, v];
                };
                fromNum.addEventListener("input", syncFrom);
                toNum.addEventListener("input", syncTo);

                const open = () => {
                    if (currentOpen && currentOpen.root !== root) currentOpen.close();
                    setStagedFromApplied();
                    pop.hidden = false; btn.setAttribute("aria-expanded", "true");

                    const { restore } = portalOpen(pop, btn);
                    portalRestore = restore;
                    ensureOverlay(); moveOverlayOnTop(); lockScrollBody(true);
                    if (isMobile()) {
                        startKeyframe(pop, "open");
                        detachSwipe = attachSwipe(pop, api);
                    }
                    currentOpen = { root, pop, trigger: btn, close: api.close };
                };

                const reallyHide = () => { pop.hidden = true; };

                const close = (opts = {}) => {
                    const { animatedFromY = null, alreadyAnimated = false } = opts;

                    const finalize = () => {
                        removeOverlay(); lockScrollBody(false);
                        reallyHide();
                        if (portalRestore) { portalRestore(); portalRestore = null; }
                        btn.setAttribute("aria-expanded", "false");
                        if (currentOpen && currentOpen.root === root) currentOpen = null;
                    };

                    if (detachSwipe) { detachSwipe(); detachSwipe = null; }

                    if (isMobile()) {
                        if (alreadyAnimated) {
                            finalize();
                        } else if (Number.isFinite(animatedFromY) && animatedFromY > 0) {
                            animateFromTo(pop, animatedFromY, "translateY(100%)", 180, "ease", finalize);
                        } else {
                            startKeyframe(pop, "close");
                            setTimeout(finalize, 180);
                        }
                        setTimeout(() => { pop.style.transform = ""; pop.style.animation = ""; }, 200);
                    } else {
                        desktopFadeOut(pop, finalize);
                    }
                };

                const trapFocus = (e) => {
                    if (e.key !== "Tab") return;
                    const f = pop.querySelectorAll("input,button,.noUi-handle,[tabindex]:not([tabindex='-1'])");
                    if (!f.length) return;
                    const first = f[0], last = f[f.length - 1];
                    if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
                    else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
                };

                ["pointerdown", "mousedown", "touchstart", "click"].forEach(ev => {
                    pop.addEventListener(ev, (ev2) => ev2.stopPropagation(), { passive: ev === "touchstart" });
                });

                btn.addEventListener("click", (e) => { e.stopPropagation(); (pop.hidden ? open : api.close)(); });
                btn.addEventListener("keydown", (e) => { if (e.key === "Enter" || e.key === " ") { e.preventDefault(); (pop.hidden ? open : api.close)(); } });
                pop.addEventListener("keydown", (e) => { if (e.key === "Escape") { e.stopPropagation(); api.close(); } });
                pop.addEventListener("keydown", trapFocus);
                const closeXRange = pop.querySelector(".js-exs-close");
                closeXRange?.addEventListener("click", () => api.close());

                pop.addEventListener("click", (e) => {
                    const action = e.target?.dataset?.action;
                    if (action === "reset") {
                        resetRange();
                        root.dispatchEvent(new CustomEvent("exs-apply", { detail: { field: field, values: applied } }));
                        api.close();
                        submitAjax();
                    }
                    if (action === "apply") {
                        commitRange();
                        root.dispatchEvent(new CustomEvent("exs-apply", { detail: { field: field, values: applied } }));
                        api.close();
                        submitAjax();
                    }
                });

                readHidden();
                if (!applied.length) {
                    applied = [String(min), String(max)];
                    writeHidden();
                }
                setStagedFromApplied();
                updateBtn();

                var api = { root, pop, trigger: btn, close };
                extraSelectRegistry.set(root, {
                    field,
                    type,
                    commitFromUi: commitRange,
                    resetForAll: resetRange,
                    isActive: () => hasActive
                });

            } else if (type === "radio") {
                const radios = pop ? [...pop.querySelectorAll('input[type="radio"]')] : [];

                const defaultRadio = radios.find(r => r.dataset.isDefault === "true");
                defaultRadioValue = defaultRadio ? defaultRadio.value : (radios[0]?.value || "");

                const syncRadiosFromApplied = () => {
                    const val = applied[0] || "";
                    radios.forEach(r => { r.checked = (r.value === val); });
                };

                const setRadioValue = (val) => {
                    const next = val || "";
                    applied = [next];
                    syncRadiosFromApplied();
                    writeHidden();
                    updateBtn();
                };

                const commitFromRadios = () => {
                    const selected = radios.find(r => r.checked) || radios.find(r => r.value === defaultRadioValue) || radios[0];
                    setRadioValue(selected ? selected.value : defaultRadioValue);
                };

                const resetRadios = () => {
                    setRadioValue(defaultRadioValue);
                };

                const open = () => {
                    if (currentOpen && currentOpen.root !== root) currentOpen.close();
                    syncRadiosFromApplied();
                    pop.hidden = false; btn.setAttribute("aria-expanded", "true");

                    const { restore } = portalOpen(pop, btn);
                    portalRestore = restore;
                    ensureOverlay(); moveOverlayOnTop(); lockScrollBody(true);
                    if (isMobile()) {
                        startKeyframe(pop, "open");
                        detachSwipe = attachSwipe(pop, api);
                    }

                    currentOpen = { root, pop, trigger: btn, close: api.close };
                    (radios.find(x => x.checked) || radios[0])?.focus();
                };

                const reallyHide = () => { pop.hidden = true; };

                const close = (opts = {}) => {
                    const { animatedFromY = null, alreadyAnimated = false } = opts;

                    const finalize = () => {
                        removeOverlay(); lockScrollBody(false);
                        reallyHide();
                        if (portalRestore) { portalRestore(); portalRestore = null; }
                        btn.setAttribute("aria-expanded", "false");
                        if (currentOpen && currentOpen.root === root) currentOpen = null;
                    };

                    if (detachSwipe) { detachSwipe(); detachSwipe = null; }

                    if (isMobile()) {
                        if (alreadyAnimated) {
                            finalize();
                        } else if (Number.isFinite(animatedFromY) && animatedFromY > 0) {
                            animateFromTo(pop, animatedFromY, "translateY(100%)", 180, "ease", finalize);
                        } else {
                            startKeyframe(pop, "close");
                            setTimeout(finalize, 180);
                        }
                        setTimeout(() => { pop.style.transform = ""; pop.style.animation = ""; }, 200);
                    } else {
                        desktopFadeOut(pop, finalize);
                    }
                };

                ["pointerdown", "mousedown", "touchstart", "click"].forEach(ev => {
                    pop.addEventListener(ev, (ev2) => ev2.stopPropagation(), { passive: ev === "touchstart" });
                });

                btn.addEventListener("click", (e) => { e.stopPropagation(); (pop.hidden ? open : api.close)(); });
                btn.addEventListener("keydown", (e) => { if (e.key === "Enter" || e.key === " ") { e.preventDefault(); (pop.hidden ? open : api.close)(); } });
                const closeXRadio = pop.querySelector(".js-exs-close");
                closeXRadio?.addEventListener("click", () => api.close());

                pop.addEventListener("change", (e) => {
                    const r = e.target;
                    if (r && r.type === "radio") {
                        setRadioValue(r.value);
                        root.dispatchEvent(new CustomEvent("exs-apply", { detail: { field: field, values: applied, instant: true } }));
                        api.close();
                        submitAjax();
                    }
                });

                readHidden();
                setRadioValue(applied[0] || defaultRadioValue);

                var api = { root, pop, trigger: btn, close };
                extraSelectRegistry.set(root, {
                    field,
                    type,
                    commitFromUi: commitFromRadios,
                    resetForAll: resetRadios,
                    defaultValue: defaultRadioValue,
                    isActive: () => hasActive
                });

            } else if (type === "stub") {
                const open = () => {
                    if (currentOpen && currentOpen.root !== root) currentOpen.close();
                    if (pop) { pop.hidden = false; btn.setAttribute("aria-expanded", "true"); }
                    const { restore } = portalOpen(pop, btn);
                    portalRestore = restore;
                    ensureOverlay(); moveOverlayOnTop(); lockScrollBody(true);
                    if (isMobile()) {
                        startKeyframe(pop, "open");
                        detachSwipe = attachSwipe(pop, api);
                    }
                    currentOpen = { root, pop, trigger: btn, close: api.close };
                };
                const reallyHide = () => { if (pop) pop.hidden = true; };
                const close = (opts = {}) => {
                    const { animatedFromY = null, alreadyAnimated = false } = opts;
                    const finalize = () => {
                        removeOverlay(); lockScrollBody(false);
                        reallyHide();
                        if (portalRestore) { portalRestore(); portalRestore = null; }
                        btn.setAttribute("aria-expanded", "false");
                        if (currentOpen && currentOpen.root === root) currentOpen = null;
                    };
                    if (detachSwipe) { detachSwipe(); detachSwipe = null; }
                    if (isMobile()) {
                        if (alreadyAnimated) { finalize(); }
                        else if (Number.isFinite(animatedFromY) && animatedFromY > 0) {
                            animateFromTo(pop, animatedFromY, "translateY(100%)", 180, "ease", finalize);
                        } else {
                            startKeyframe(pop, "close");
                            setTimeout(finalize, 180);
                        }
                        setTimeout(() => { pop.style.transform = ""; pop.style.animation = ""; }, 200);
                    } else {
                        desktopFadeOut(pop, finalize);
                    }
                };

                ["pointerdown", "mousedown", "touchstart", "click"].forEach(ev => {
                    pop.addEventListener(ev, (ev2) => ev2.stopPropagation(), { passive: ev === "touchstart" });
                });

                btn.addEventListener("click", (e) => { e.stopPropagation(); (pop.hidden ? open : api.close)(); });
                const closeXStub = pop.querySelector(".js-exs-close");
                closeXStub?.addEventListener("click", () => api.close());
                pop.addEventListener("click", (e) => {
                    const action = e.target?.dataset?.action;
                    if (action === "reset") { api.close(); submitAjax(); }
                    if (action === "apply") { api.close(); submitAjax(); }
                });

                updateBtn();
                var api = { root, pop, trigger: btn, close };
                extraSelectRegistry.set(root, {
                    field,
                    type,
                    commitFromUi: null,
                    resetForAll: null,
                    isActive: () => hasActive
                });
            }
        });

        updateFiltersBadge();

        const openBtn  = document.querySelector(".js-filters-open");
        const closeBtn = filters.querySelector(".js-filters-close");
        const resetAll = filters.querySelector(".js-filters-reset-all");
        const applyAll = filters.querySelector(".js-filters-apply-all");
        const scope    = filters.querySelector("[data-filters-scope]");

        let modalBackdrop = null;
        const createBackdrop = () => {
            if (modalBackdrop) return;
            modalBackdrop = document.createElement("div");
            modalBackdrop.className = "modal-backdrop";
            let downOnBackdrop = false;

            modalBackdrop.addEventListener("mousedown", () => { downOnBackdrop = true; }, { passive: true });
            modalBackdrop.addEventListener("mouseup", () => {
                if (downOnBackdrop) {
                    if (currentOpen) { currentOpen.close(); }
                    else { closeModal(); }
                }
                downOnBackdrop = false;
            }, { passive: true });

            document.body.appendChild(modalBackdrop);
        };
        const removeBackdrop = () => {
            if (!modalBackdrop) return;
            modalBackdrop.remove();
            modalBackdrop = null;
        };

        const lockPage = (on) => { document.body.style.overflow = on ? "hidden" : ""; };

        const modalFocusTrap = (e) => {
            if (!document.body.classList.contains("filters-modal")) return;
            if (e.key !== "Tab") return;
            const focusables = filters.querySelectorAll("button, input, [tabindex]:not([tabindex='-1'])");
            if (!focusables.length) return;
            const first = focusables[0], last = focusables[focusables.length - 1];
            if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
            else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
        };

        const closeAllPopovers = () => {
            document.querySelectorAll(".exs-popover:not([hidden])").forEach(p => {
                const root = p.closest(".extra-select");
                root?.querySelector(".js-exs-trigger")?.click();
            });
        };

        const openModal = () => {
            closeAllPopovers();
            createGhost();
            document.body.classList.add("filters-modal");
            createBackdrop();
            lockPage(true);
            document.addEventListener("keydown", modalFocusTrap);
            closeBtn?.focus();
        };

        const closeModal = () => {
            closeAllPopovers();
            document.body.classList.remove("filters-modal");
            removeBackdrop();
            removeGhost();
            lockPage(false);
            document.removeEventListener("keydown", modalFocusTrap);
            openBtn?.focus();
        };

        openBtn?.addEventListener("click", openModal);
        closeBtn?.addEventListener("click", closeModal);
        document.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && document.body.classList.contains("filters-modal")) closeModal();
        });

        resetAll?.addEventListener("click", () => {
            extraSelectRegistry.forEach((api) => {
                if (typeof api.resetForAll === "function") {
                    api.resetForAll();
                }
            });

            scope.querySelectorAll('.filters-extra-checks input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });

            updateFiltersBadge();
            submitAjax();
        });

        applyAll?.addEventListener("click", () => {
            extraSelectRegistry.forEach((api) => {
                if (typeof api.commitFromUi === "function") {
                    api.commitFromUi();
                }
            });

            submitAjax();
            closeModal();
        });
    })();
</script>
</body>
</html>
